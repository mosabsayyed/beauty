(.venv) root@MOSAB:/home/mosab/projects/chatmodule# cd /home/mosab/projects/chatmodule
source backend/.venv/bin/activate
set -a && source .env && set +a && python3 backend/tools/neo4j_embedding_probe.py
{
  "uri": "neo4j+s://097a9e5c.databases.neo4j.io",
  "database": "neo4j",
  "procedures": [
    {
      "name": "apoc.algo.aStar",
      "signature": "apoc.algo.aStar(startNode :: NODE, endNode :: NODE, relTypesAndDirections :: STRING, weightPropertyName :: STRING, latPropertyName :: STRING, lonPropertyName :: STRING) :: (path :: PATH, weight :: FLOAT)",
      "description": "Runs the A* search algorithm to find the optimal path between two `NODE` values, using the given `RELATIONSHIP` property name for the cost function."
    },
    {
      "name": "apoc.algo.aStarConfig",
      "signature": "apoc.algo.aStarConfig(startNode :: NODE, endNode :: NODE, relTypesAndDirections :: STRING, config :: MAP) :: (path :: PATH, weight :: FLOAT)",
      "description": "Runs the A* search algorithm to find the optimal path between two `NODE` values, using the given `RELATIONSHIP` property name for the cost function.\nThis procedure looks for weight, latitude and longitude properties in the config."
    },
    {
      "name": "apoc.algo.allSimplePaths",
      "signature": "apoc.algo.allSimplePaths(startNode :: NODE, endNode :: NODE, relTypesAndDirections :: STRING, maxNodes :: INTEGER) :: (path :: PATH)",
      "description": "Runs a search algorithm to find all of the simple paths between the given `RELATIONSHIP` values, up to a max depth described by `maxNodes`.\nThe returned paths will not contain loops."
    },
    {
      "name": "apoc.algo.cover",
      "signature": "apoc.algo.cover(nodes :: ANY) :: (rel :: RELATIONSHIP)",
      "description": "Returns all `RELATIONSHIP` values connecting the given set of `NODE` values."
    },
    {
      "name": "apoc.algo.dijkstra",
      "signature": "apoc.algo.dijkstra(startNode :: NODE, endNode :: NODE, relTypesAndDirections :: STRING, weightPropertyName :: STRING, defaultWeight = NaN :: FLOAT, numberOfWantedPaths = 1 :: INTEGER) :: (path :: PATH, weight :: FLOAT)",
      "description": "Runs Dijkstra's algorithm using the given `RELATIONSHIP` property as the cost function."
    },
    {
      "name": "apoc.atomic.add",
      "signature": "apoc.atomic.add(container :: ANY, propertyName :: STRING, number :: INTEGER | FLOAT, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)",
      "description": "Sets the given property to the sum of itself and the given `INTEGER` or `FLOAT` value.\nThe procedure then sets the property to the returned sum."
    },
    {
      "name": "apoc.atomic.concat",
      "signature": "apoc.atomic.concat(container :: ANY, propertyName :: STRING, string :: STRING, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)",
      "description": "Sets the given property to the concatenation of itself and the `STRING` value.\nThe procedure then sets the property to the returned `STRING`."
    },
    {
      "name": "apoc.atomic.insert",
      "signature": "apoc.atomic.insert(container :: ANY, propertyName :: STRING, position :: INTEGER, value :: ANY, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)",
      "description": "Inserts a value at position into the `LIST<ANY>` value of a property.\nThe procedure then sets the result back on the property."
    },
    {
      "name": "apoc.atomic.remove",
      "signature": "apoc.atomic.remove(container :: ANY, propertyName :: STRING, position :: INTEGER, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)",
      "description": "Removes the element at position from the `LIST<ANY>` value of a property.\nThe procedure then sets the property to the resulting `LIST<ANY>` value."
    },
    {
      "name": "apoc.atomic.subtract",
      "signature": "apoc.atomic.subtract(container :: ANY, propertyName :: STRING, number :: INTEGER | FLOAT, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)",
      "description": "Sets the property of a value to itself minus the given `INTEGER` or `FLOAT` value.\nThe procedure then sets the property to the returned sum."
    },
    {
      "name": "apoc.atomic.update",
      "signature": "apoc.atomic.update(container :: ANY, propertyName :: STRING, operation :: STRING, retryAttempts = 5 :: INTEGER) :: (container :: ANY, property :: STRING, oldValue :: ANY, newValue :: ANY)",
      "description": "Updates the value of a property with a Cypher operation."
    },
    {
      "name": "apoc.case",
      "signature": "apoc.case(conditionals :: LIST<ANY>, elseQuery =  :: STRING, params = {} :: MAP) :: (value :: MAP)",
      "description": "For each pair of conditional and read-only queries in the given `LIST<ANY>`, this procedure will run the first query for which the conditional is evaluated to true. If none of the conditionals are true, the `ELSE` query will run instead."
    },
    {
      "name": "apoc.coll.elements",
      "signature": "apoc.coll.elements(coll :: LIST<ANY>, limit = -1 :: INTEGER, offset = 0 :: INTEGER) :: (_1 :: ANY, _2 :: ANY, _3 :: ANY, _4 :: ANY, _5 :: ANY, _6 :: ANY, _7 :: ANY, _8 :: ANY, _9 :: ANY, _10 :: ANY, _1s :: STRING, _2s :: STRING, _3s :: STRING, _4s :: STRING, _5s :: STRING, _6s :: STRING, _7s :: STRING, _8s :: STRING, _9s :: STRING, _10s :: STRING, _1i :: INTEGER, _2i :: INTEGER, _3i :: INTEGER, _4i :: INTEGER, _5i :: INTEGER, _6i :: INTEGER, _7i :: INTEGER, _8i :: INTEGER, _9i :: INTEGER, _10i :: INTEGER, _1f :: FLOAT, _2f :: FLOAT, _3f :: FLOAT, _4f :: FLOAT, _5f :: FLOAT, _6f :: FLOAT, _7f :: FLOAT, _8f :: FLOAT, _9f :: FLOAT, _10f :: FLOAT, _1b :: BOOLEAN, _2b :: BOOLEAN, _3b :: BOOLEAN, _4b :: BOOLEAN, _5b :: BOOLEAN, _6b :: BOOLEAN, _7b :: BOOLEAN, _8b :: BOOLEAN, _9b :: BOOLEAN, _10b :: BOOLEAN, _1l :: LIST<ANY>, _2l :: LIST<ANY>, _3l :: LIST<ANY>, _4l :: LIST<ANY>, _5l :: LIST<ANY>, _6l :: LIST<ANY>, _7l :: LIST<ANY>, _8l :: LIST<ANY>, _9l :: LIST<ANY>, _10l :: LIST<ANY>, _1m :: MAP, _2m :: MAP, _3m :: MAP, _4m :: MAP, _5m :: MAP, _6m :: MAP, _7m :: MAP, _8m :: MAP, _9m :: MAP, _10m :: MAP, _1n :: NODE, _2n :: NODE, _3n :: NODE, _4n :: NODE, _5n :: NODE, _6n :: NODE, _7n :: NODE, _8n :: NODE, _9n :: NODE, _10n :: NODE, _1r :: RELATIONSHIP, _2r :: RELATIONSHIP, _3r :: RELATIONSHIP, _4r :: RELATIONSHIP, _5r :: RELATIONSHIP, _6r :: RELATIONSHIP, _7r :: RELATIONSHIP, _8r :: RELATIONSHIP, _9r :: RELATIONSHIP, _10r :: RELATIONSHIP, _1p :: PATH, _2p :: PATH, _3p :: PATH, _4p :: PATH, _5p :: PATH, _6p :: PATH, _7p :: PATH, _8p :: PATH, _9p :: PATH, _10p :: PATH, elements :: INTEGER)",
      "description": "Deconstructs a `LIST<ANY>` into identifiers indicating their specific type."
    },
    {
      "name": "apoc.coll.partition",
      "signature": "apoc.coll.partition(coll :: LIST<ANY>, batchSize :: INTEGER) :: (value :: LIST<ANY>)",
      "description": "Partitions the original `LIST<ANY>` into a new `LIST<ANY>` of the given batch size.\nThe final `LIST<ANY>` may be smaller than the given batch size."
    },
    {
      "name": "apoc.coll.split",
      "signature": "apoc.coll.split(coll :: LIST<ANY>, value :: ANY) :: (value :: LIST<ANY>)",
      "description": "Splits a collection by the given value.\nThe value itself will not be part of the resulting `LIST<ANY>` values."
    },
    {
      "name": "apoc.coll.zipToRows",
      "signature": "apoc.coll.zipToRows(list1 :: LIST<ANY>, list2 :: LIST<ANY>) :: (value :: LIST<ANY>)",
      "description": "Returns the two `LIST<ANY>` values zipped together, with one row per zipped pair."
    },
    {
      "name": "apoc.convert.setJsonProperty",
      "signature": "apoc.convert.setJsonProperty(node :: NODE, key :: STRING, value :: ANY)",
      "description": "Serializes the given JSON object and sets it as a property on the given `NODE`."
    },
    {
      "name": "apoc.convert.toTree",
      "signature": "apoc.convert.toTree(paths :: LIST<PATH>, lowerCaseRels = true :: BOOLEAN, config = {} :: MAP) :: (value :: MAP)",
      "description": "Returns a stream of `MAP` values, representing the given `PATH` values as a tree with at least one root."
    },
    {
      "name": "apoc.create.addLabels",
      "signature": "apoc.create.addLabels(nodes :: ANY, labels :: LIST<STRING>) :: (node :: NODE)",
      "description": "Adds the given labels to the given `NODE` values."
    },
    {
      "name": "apoc.create.clonePathToVirtual",
      "signature": "apoc.create.clonePathToVirtual(path :: PATH) :: (path :: PATH)",
      "description": "Takes the given `PATH` and returns a virtual representation of it."
    },
    {
      "name": "apoc.create.clonePathsToVirtual",
      "signature": "apoc.create.clonePathsToVirtual(paths :: LIST<PATH>) :: (path :: PATH)",
      "description": "Takes the given `LIST<PATH>` and returns a virtual representation of them."
    },
    {
      "name": "apoc.create.node",
      "signature": "apoc.create.node(labels :: LIST<STRING>, props :: MAP) :: (node :: NODE)",
      "description": "Creates a `NODE` with the given dynamic labels."
    },
    {
      "name": "apoc.create.nodes",
      "signature": "apoc.create.nodes(labels :: LIST<STRING>, props :: LIST<MAP>) :: (node :: NODE)",
      "description": "Creates `NODE` values with the given dynamic labels."
    },
    {
      "name": "apoc.create.relationship",
      "signature": "apoc.create.relationship(from :: NODE, relType :: STRING, props :: MAP, to :: NODE) :: (rel :: RELATIONSHIP)",
      "description": "Creates a `RELATIONSHIP` with the given dynamic relationship type."
    },
    {
      "name": "apoc.create.removeLabels",
      "signature": "apoc.create.removeLabels(nodes :: ANY, labels :: LIST<STRING>) :: (node :: NODE)",
      "description": "Removes the given labels from the given `NODE` values."
    },
    {
      "name": "apoc.create.removeProperties",
      "signature": "apoc.create.removeProperties(nodes :: ANY, keys :: LIST<STRING>) :: (node :: NODE)",
      "description": "Removes the given properties from the given `NODE` values."
    },
    {
      "name": "apoc.create.removeRelProperties",
      "signature": "apoc.create.removeRelProperties(rels :: ANY, keys :: LIST<STRING>) :: (rel :: RELATIONSHIP)",
      "description": "Removes the given properties from the given `RELATIONSHIP` values."
    },
    {
      "name": "apoc.create.setLabels",
      "signature": "apoc.create.setLabels(nodes :: ANY, labels :: LIST<STRING>) :: (node :: NODE)",
      "description": "Sets the given labels to the given `NODE` values. Non-matching labels are removed from the nodes."
    },
    {
      "name": "apoc.create.setProperties",
      "signature": "apoc.create.setProperties(nodes :: ANY, keys :: LIST<STRING>, values :: LIST<ANY>) :: (node :: NODE)",
      "description": "Sets the given properties to the given `NODE` values."
    },
    {
      "name": "apoc.create.setProperty",
      "signature": "apoc.create.setProperty(nodes :: ANY, key :: STRING, value :: ANY) :: (node :: NODE)",
      "description": "Sets the given property to the given `NODE` values."
    },
    {
      "name": "apoc.create.setRelProperties",
      "signature": "apoc.create.setRelProperties(rels :: ANY, keys :: LIST<STRING>, values :: LIST<ANY>) :: (rel :: RELATIONSHIP)",
      "description": "Sets the given properties on the `RELATIONSHIP` values."
    },
    {
      "name": "apoc.create.setRelProperty",
      "signature": "apoc.create.setRelProperty(rels :: ANY, key :: STRING, value :: ANY) :: (rel :: RELATIONSHIP)",
      "description": "Sets the given property on the `RELATIONSHIP` values."
    },
    {
      "name": "apoc.create.uuids",
      "signature": "apoc.create.uuids(count :: INTEGER) :: (row :: INTEGER, uuid :: STRING)",
      "description": "Returns a stream of UUIDs."
    },
    {
      "name": "apoc.create.vNode",
      "signature": "apoc.create.vNode(labels :: LIST<STRING>, props :: MAP) :: (node :: NODE)",
      "description": "Returns a virtual `NODE`."
    },
    {
      "name": "apoc.create.vNodes",
      "signature": "apoc.create.vNodes(labels :: LIST<STRING>, props :: LIST<MAP>) :: (node :: NODE)",
      "description": "Returns virtual `NODE` values."
    },
    {
      "name": "apoc.create.vRelationship",
      "signature": "apoc.create.vRelationship(from :: NODE, relType :: STRING, props :: MAP, to :: NODE) :: (rel :: RELATIONSHIP)",
      "description": "Returns a virtual `RELATIONSHIP`."
    },
    {
      "name": "apoc.create.virtualPath",
      "signature": "apoc.create.virtualPath(labelsN :: LIST<STRING>, n :: MAP, arelType :: STRING, props :: MAP, labelsM :: LIST<STRING>, m :: MAP) :: (from :: NODE, rel :: RELATIONSHIP, to :: NODE)",
      "description": "Returns a virtual `PATH`."
    },
    {
      "name": "apoc.cypher.doIt",
      "signature": "apoc.cypher.doIt(statement :: STRING, params :: MAP) :: (value :: MAP)",
      "description": "Runs a dynamically constructed statement with the given parameters. This procedure allows for both read and write statements."
    },
    {
      "name": "apoc.cypher.run",
      "signature": "apoc.cypher.run(statement :: STRING, params :: MAP) :: (value :: MAP)",
      "description": "Runs a dynamically constructed read-only statement with the given parameters."
    },
    {
      "name": "apoc.cypher.runMany",
      "signature": "apoc.cypher.runMany(statement :: STRING, params :: MAP, config = {} :: MAP) :: (row :: INTEGER, result :: MAP)",
      "description": "Runs each semicolon separated statement and returns a summary of the statement outcomes."
    },
    {
      "name": "apoc.cypher.runTimeboxed",
      "signature": "apoc.cypher.runTimeboxed(statement :: STRING, params :: MAP, timeout :: INTEGER) :: (value :: MAP)",
      "description": "Terminates a Cypher statement if it has not finished before the set timeout (ms)."
    },
    {
      "name": "apoc.do.case",
      "signature": "apoc.do.case(conditionals :: LIST<ANY>, elseQuery =  :: STRING, params = {} :: MAP) :: (value :: MAP)",
      "description": "For each pair of conditional queries in the given `LIST<ANY>`, this procedure will run the first query for which the conditional is evaluated to true.\nIf none of the conditionals are true, the `ELSE` query will run instead."
    },
    {
      "name": "apoc.do.when",
      "signature": "apoc.do.when(condition :: BOOLEAN, ifQuery :: STRING, elseQuery :: STRING, params = {} :: MAP) :: (value :: MAP)",
      "description": "Runs the given read/write `ifQuery` if the conditional has evaluated to true, otherwise the `elseQuery` will run."
    },
    {
      "name": "apoc.example.movies",
      "signature": "apoc.example.movies() :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Seeds the database with the Neo4j movie dataset."
    },
    {
      "name": "apoc.export.csv.all",
      "signature": "apoc.export.csv.all(file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the full database to the provided CSV file."
    },
    {
      "name": "apoc.export.csv.data",
      "signature": "apoc.export.csv.data(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the given `NODE` and `RELATIONSHIP` values to the provided CSV file."
    },
    {
      "name": "apoc.export.csv.graph",
      "signature": "apoc.export.csv.graph(graph :: MAP, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the given graph to the provided CSV file."
    },
    {
      "name": "apoc.export.csv.query",
      "signature": "apoc.export.csv.query(query :: STRING, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the results from running the given Cypher query to the provided CSV file."
    },
    {
      "name": "apoc.export.cypher.all",
      "signature": "apoc.export.cypher.all(file =  :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)",
      "description": "Exports the full database (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell)."
    },
    {
      "name": "apoc.export.cypher.data",
      "signature": "apoc.export.cypher.data(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, file =  :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)",
      "description": "Exports the given `NODE` and `RELATIONSHIP` values (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell)."
    },
    {
      "name": "apoc.export.cypher.graph",
      "signature": "apoc.export.cypher.graph(graph :: MAP, file :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)",
      "description": "Exports the given graph (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell)."
    },
    {
      "name": "apoc.export.cypher.query",
      "signature": "apoc.export.cypher.query(statement :: STRING, file =  :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)",
      "description": "Exports the `NODE` and `RELATIONSHIP` values from the given Cypher query (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell)."
    },
    {
      "name": "apoc.export.cypher.schema",
      "signature": "apoc.export.cypher.schema(file =  :: STRING, config = {} :: MAP) :: (file :: STRING, batches :: INTEGER, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, cypherStatements :: ANY, nodeStatements :: ANY, relationshipStatements :: ANY, schemaStatements :: ANY, cleanupStatements :: ANY)",
      "description": "Exports all schema indexes and constraints to Cypher statements."
    },
    {
      "name": "apoc.export.graphml.all",
      "signature": "apoc.export.graphml.all(file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the full database to the provided GraphML file."
    },
    {
      "name": "apoc.export.graphml.data",
      "signature": "apoc.export.graphml.data(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the given `NODE` and `RELATIONSHIP` values to the provided GraphML file."
    },
    {
      "name": "apoc.export.graphml.graph",
      "signature": "apoc.export.graphml.graph(graph :: MAP, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the given graph to the provided GraphML file."
    },
    {
      "name": "apoc.export.graphml.query",
      "signature": "apoc.export.graphml.query(statement :: STRING, file :: STRING, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the given `NODE` and `RELATIONSHIP` values from the Cypher statement to the provided GraphML file."
    },
    {
      "name": "apoc.export.json.all",
      "signature": "apoc.export.json.all(file :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the full database to the provided JSON file."
    },
    {
      "name": "apoc.export.json.data",
      "signature": "apoc.export.json.data(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, file :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the given `NODE` and `RELATIONSHIP` values to the provided JSON file."
    },
    {
      "name": "apoc.export.json.graph",
      "signature": "apoc.export.json.graph(graph :: MAP, file :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the given graph to the provided JSON file."
    },
    {
      "name": "apoc.export.json.query",
      "signature": "apoc.export.json.query(statement :: STRING, file :: STRING, config = {} :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Exports the results from the Cypher statement to the provided JSON file."
    },
    {
      "name": "apoc.graph.from",
      "signature": "apoc.graph.from(data :: ANY, name :: STRING, props :: MAP) :: (graph :: MAP)",
      "description": "Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the given data."
    },
    {
      "name": "apoc.graph.fromCypher",
      "signature": "apoc.graph.fromCypher(statement :: STRING, params :: MAP, name :: STRING, props :: MAP) :: (graph :: MAP)",
      "description": "Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given Cypher statement."
    },
    {
      "name": "apoc.graph.fromDB",
      "signature": "apoc.graph.fromDB(name :: STRING, props :: MAP) :: (graph :: MAP)",
      "description": "Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given database."
    },
    {
      "name": "apoc.graph.fromData",
      "signature": "apoc.graph.fromData(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>, name :: STRING, props :: MAP) :: (graph :: MAP)",
      "description": "Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the given data."
    },
    {
      "name": "apoc.graph.fromDocument",
      "signature": "apoc.graph.fromDocument(json :: ANY, config = {} :: MAP) :: (graph :: MAP)",
      "description": "Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given JSON file."
    },
    {
      "name": "apoc.graph.fromPath",
      "signature": "apoc.graph.fromPath(path :: PATH, name :: STRING, props :: MAP) :: (graph :: MAP)",
      "description": "Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given `PATH`."
    },
    {
      "name": "apoc.graph.fromPaths",
      "signature": "apoc.graph.fromPaths(paths :: LIST<PATH>, name :: STRING, props :: MAP) :: (graph :: MAP)",
      "description": "Generates a virtual sub-graph by extracting all of the `NODE` and `RELATIONSHIP` values from the data returned by the given `PATH` values."
    },
    {
      "name": "apoc.graph.validateDocument",
      "signature": "apoc.graph.validateDocument(json :: ANY, config = {} :: MAP) :: (row :: MAP)",
      "description": "Validates the JSON file and returns the result of the validation."
    },
    {
      "name": "apoc.help",
      "signature": "apoc.help(proc :: STRING) :: (type :: STRING, name :: STRING, text :: STRING, signature :: STRING, roles :: LIST<STRING>, writes :: BOOLEAN, core :: BOOLEAN, isDeprecated :: BOOLEAN)",
      "description": "Returns descriptions of the available APOC procedures and functions. If a keyword is provided, it will return only those procedures and functions that have the keyword in their name."
    },
    {
      "name": "apoc.import.csv",
      "signature": "apoc.import.csv(nodes :: LIST<MAP>, rels :: LIST<MAP>, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Imports `NODE` and `RELATIONSHIP` values with the given labels and types from the provided CSV file."
    },
    {
      "name": "apoc.import.graphml",
      "signature": "apoc.import.graphml(urlOrBinaryFile :: ANY, config :: MAP) :: (file :: STRING, source :: STRING, format :: STRING, nodes :: INTEGER, relationships :: INTEGER, properties :: INTEGER, time :: INTEGER, rows :: INTEGER, batchSize :: INTEGER, batches :: INTEGER, done :: BOOLEAN, data :: ANY)",
      "description": "Imports a graph from the provided GraphML file."
    },
    {
      "name": "apoc.load.json",
      "signature": "apoc.load.json(urlOrKeyOrBinary :: ANY, path =  :: STRING, config = {} :: MAP) :: (value :: MAP)",
      "description": "Imports JSON file as a stream of values if the given JSON file is a `LIST<ANY>`.\nIf the given JSON file is a `MAP`, this procedure imports a single value instead."
    },
    {
      "name": "apoc.load.jsonArray",
      "signature": "apoc.load.jsonArray(url :: STRING, path =  :: STRING, config = {} :: MAP) :: (value :: ANY)",
      "description": "Loads array from a JSON URL (e.g. web-API) to then import the given JSON file as a stream of values."
    },
    {
      "name": "apoc.load.xml",
      "signature": "apoc.load.xml(urlOrBinary :: ANY, path = / :: STRING, config = {} :: MAP, simple = false :: BOOLEAN) :: (value :: MAP)",
      "description": "Loads a single nested `MAP` from an XML URL (e.g. web-API)."
    },
    {
      "name": "apoc.lock.all",
      "signature": "apoc.lock.all(nodes :: LIST<NODE>, rels :: LIST<RELATIONSHIP>)",
      "description": "Acquires a write lock on the given `NODE` and `RELATIONSHIP` values."
    },
    {
      "name": "apoc.lock.nodes",
      "signature": "apoc.lock.nodes(nodes :: LIST<NODE>)",
      "description": "Acquires a write lock on the given `NODE` values."
    },
    {
      "name": "apoc.lock.read.nodes",
      "signature": "apoc.lock.read.nodes(nodes :: LIST<NODE>)",
      "description": "Acquires a read lock on the given `NODE` values."
    },
    {
      "name": "apoc.lock.read.rels",
      "signature": "apoc.lock.read.rels(rels :: LIST<RELATIONSHIP>)",
      "description": "Acquires a read lock on the given `RELATIONSHIP` values."
    },
    {
      "name": "apoc.lock.rels",
      "signature": "apoc.lock.rels(rels :: LIST<RELATIONSHIP>)",
      "description": "Acquires a write lock on the given `RELATIONSHIP` values."
    },
    {
      "name": "apoc.math.regr",
      "signature": "apoc.math.regr(label :: STRING, propertyY :: STRING, propertyX :: STRING) :: (r2 :: FLOAT, avgX :: FLOAT, avgY :: FLOAT, slope :: FLOAT)",
      "description": "Returns the coefficient of determination (R-squared) for the values of propertyY and propertyX in the given label."
    },
    {
      "name": "apoc.merge.node",
      "signature": "apoc.merge.node(labels :: LIST<STRING>, identProps :: MAP, onCreateProps = {} :: MAP, onMatchProps = {} :: MAP) :: (node :: NODE)",
      "description": "Merges the given `NODE` values with the given dynamic labels."
    },
    {
      "name": "apoc.merge.node.eager",
      "signature": "apoc.merge.node.eager(labels :: LIST<STRING>, identProps :: MAP, onCreateProps = {} :: MAP, onMatchProps = {} :: MAP) :: (node :: NODE)",
      "description": "Merges the given `NODE` values with the given dynamic labels eagerly."
    },
    {
      "name": "apoc.merge.nodeWithStats",
      "signature": "apoc.merge.nodeWithStats(labels :: LIST<STRING>, identProps :: MAP, onCreateProps = {} :: MAP, onMatchProps = {} :: MAP) :: (stats :: MAP, node :: NODE)",
      "description": "Merges the given `NODE` values with the given dynamic labels. Provides queryStatistics in the result."
    },
    {
      "name": "apoc.merge.nodeWithStats.eager",
      "signature": "apoc.merge.nodeWithStats.eager(labels :: LIST<STRING>, identProps :: MAP, onCreateProps = {} :: MAP, onMatchProps = {} :: MAP) :: (stats :: MAP, node :: NODE)",
      "description": "Merges the given `NODE` values with the given dynamic labels eagerly. Provides queryStatistics in the result."
    },
    {
      "name": "apoc.merge.relationship",
      "signature": "apoc.merge.relationship(startNode :: NODE, relType :: STRING, identProps :: MAP, onCreateProps :: MAP, endNode :: NODE, onMatchProps = {} :: MAP) :: (rel :: RELATIONSHIP)",
      "description": "Merges the given `RELATIONSHIP` values with the given dynamic types/properties."
    },
    {
      "name": "apoc.merge.relationship.eager",
      "signature": "apoc.merge.relationship.eager(startNode :: NODE, relType :: STRING, identProps :: MAP, onCreateProps :: MAP, endNode :: NODE, onMatchProps = {} :: MAP) :: (rel :: RELATIONSHIP)",
      "description": "Merges the given `RELATIONSHIP` values with the given dynamic types/properties eagerly."
    },
    {
      "name": "apoc.merge.relationshipWithStats",
      "signature": "apoc.merge.relationshipWithStats(startNode :: NODE, relType :: STRING, identProps :: MAP, onCreateProps :: MAP, endNode :: NODE, onMatchProps = {} :: MAP) :: (stats :: MAP, rel :: RELATIONSHIP)",
      "description": "Merges the given `RELATIONSHIP` values with the given dynamic types/properties. Provides queryStatistics in the result."
    },
    {
      "name": "apoc.merge.relationshipWithStats.eager",
      "signature": "apoc.merge.relationshipWithStats.eager(startNode :: NODE, relType :: STRING, identProps :: MAP, onCreateProps :: MAP, endNode :: NODE, onMatchProps = {} :: MAP) :: (stats :: MAP, rel :: RELATIONSHIP)",
      "description": "Merges the given `RELATIONSHIP` values with the given dynamic types/properties eagerly. Provides queryStatistics in the result."
    },
    {
      "name": "apoc.meta.data",
      "signature": "apoc.meta.data(config = {} :: MAP) :: (label :: STRING, property :: STRING, count :: INTEGER, unique :: BOOLEAN, index :: BOOLEAN, existence :: BOOLEAN, type :: STRING, array :: BOOLEAN, sample :: LIST<ANY>, left :: INTEGER, right :: INTEGER, other :: LIST<STRING>, otherLabels :: LIST<STRING>, elementType :: STRING)",
      "description": "Examines the full graph and returns a table of metadata."
    },
    {
      "name": "apoc.meta.data.of",
      "signature": "apoc.meta.data.of(graph :: ANY, config = {} :: MAP) :: (label :: STRING, property :: STRING, count :: INTEGER, unique :: BOOLEAN, index :: BOOLEAN, existence :: BOOLEAN, type :: STRING, array :: BOOLEAN, sample :: LIST<ANY>, left :: INTEGER, right :: INTEGER, other :: LIST<STRING>, otherLabels :: LIST<STRING>, elementType :: STRING)",
      "description": "Examines the given sub-graph and returns a table of metadata."
    },
    {
      "name": "apoc.meta.graph",
      "signature": "apoc.meta.graph(config = {} :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)",
      "description": "Examines the full graph and returns a meta-graph."
    },
    {
      "name": "apoc.meta.graph.of",
      "signature": "apoc.meta.graph.of(graph = {} :: ANY, config = {} :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)",
      "description": "Examines the given sub-graph and returns a meta-graph."
    },
    {
      "name": "apoc.meta.graphSample",
      "signature": "apoc.meta.graphSample(config = {} :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)",
      "description": "Examines the full graph and returns a meta-graph.\nUnlike `apoc.meta.graph`, this procedure does not filter away non-existing paths."
    },
    {
      "name": "apoc.meta.nodeTypeProperties",
      "signature": "apoc.meta.nodeTypeProperties(config = {} :: MAP) :: (nodeType :: STRING, nodeLabels :: LIST<STRING>, propertyName :: STRING, propertyTypes :: LIST<STRING>, mandatory :: BOOLEAN, propertyObservations :: INTEGER, totalObservations :: INTEGER)",
      "description": "Examines the full graph and returns a table of metadata with information about the `NODE` values therein."
    },
    {
      "name": "apoc.meta.relTypeProperties",
      "signature": "apoc.meta.relTypeProperties(config = {} :: MAP) :: (relType :: STRING, sourceNodeLabels :: LIST<STRING>, targetNodeLabels :: LIST<STRING>, propertyName :: STRING, propertyTypes :: LIST<STRING>, mandatory :: BOOLEAN, propertyObservations :: INTEGER, totalObservations :: INTEGER)",
      "description": "Examines the full graph and returns a table of metadata with information about the `RELATIONSHIP` values therein."
    },
    {
      "name": "apoc.meta.schema",
      "signature": "apoc.meta.schema(config = {} :: MAP) :: (value :: MAP)",
      "description": "Examines the given sub-graph and returns metadata as a `MAP`."
    },
    {
      "name": "apoc.meta.stats",
      "signature": "apoc.meta.stats() :: (labelCount :: INTEGER, relTypeCount :: INTEGER, propertyKeyCount :: INTEGER, nodeCount :: INTEGER, relCount :: INTEGER, labels :: MAP, relTypes :: MAP, relTypesCount :: MAP, stats :: MAP)",
      "description": "Returns the metadata stored in the transactional database statistics."
    },
    {
      "name": "apoc.meta.subGraph",
      "signature": "apoc.meta.subGraph(config :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)",
      "description": "Examines the given sub-graph and returns a meta-graph."
    },
    {
      "name": "apoc.neighbors.athop",
      "signature": "apoc.neighbors.athop(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (node :: NODE)",
      "description": "Returns all `NODE` values connected by the given `RELATIONSHIP` types at the specified distance."
    },
    {
      "name": "apoc.neighbors.athop.count",
      "signature": "apoc.neighbors.athop.count(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (value :: INTEGER)",
      "description": "Returns the count of all `NODE` values connected by the given `RELATIONSHIP` types at the specified distance."
    },
    {
      "name": "apoc.neighbors.byhop",
      "signature": "apoc.neighbors.byhop(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (nodes :: LIST<NODE>)",
      "description": "Returns all `NODE` values connected by the given `RELATIONSHIP` types within the specified distance. Returns `LIST<NODE>` values, where each `PATH` of `NODE` values represents one row of the `LIST<NODE>` values."
    },
    {
      "name": "apoc.neighbors.byhop.count",
      "signature": "apoc.neighbors.byhop.count(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (value :: LIST<ANY>)",
      "description": "Returns the count of all `NODE` values connected by the given `RELATIONSHIP` types within the specified distance."
    },
    {
      "name": "apoc.neighbors.tohop",
      "signature": "apoc.neighbors.tohop(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (node :: NODE)",
      "description": "Returns all `NODE` values connected by the given `RELATIONSHIP` types within the specified distance.\n`NODE` values are returned individually for each row."
    },
    {
      "name": "apoc.neighbors.tohop.count",
      "signature": "apoc.neighbors.tohop.count(node :: NODE, relTypes =  :: STRING, distance = 1 :: INTEGER) :: (value :: INTEGER)",
      "description": "Returns the count of all `NODE` values connected by the given `RELATIONSHIP` values in the pattern within the specified distance."
    },
    {
      "name": "apoc.nodes.collapse",
      "signature": "apoc.nodes.collapse(nodes :: LIST<NODE>, config = {} :: MAP) :: (from :: NODE, rel :: RELATIONSHIP, to :: NODE)",
      "description": "Merges `NODE` values together in the given `LIST<NODE>`.\nThe `NODE` values are then combined to become one `NODE`, with all labels of the previous `NODE` values attached to it, and all `RELATIONSHIP` values pointing to it."
    },
    {
      "name": "apoc.nodes.cycles",
      "signature": "apoc.nodes.cycles(nodes :: LIST<NODE>, config = {} :: MAP) :: (path :: PATH)",
      "description": "Detects all `PATH` cycles in the given `LIST<NODE>`.\nThis procedure can be limited on `RELATIONSHIP` values as well."
    },
    {
      "name": "apoc.nodes.delete",
      "signature": "apoc.nodes.delete(nodes :: ANY, batchSize :: INTEGER) :: (value :: INTEGER)",
      "description": "Deletes all `NODE` values with the given ids."
    },
    {
      "name": "apoc.nodes.get",
      "signature": "apoc.nodes.get(nodes :: ANY) :: (node :: NODE)",
      "description": "Returns all `NODE` values with the given ids."
    },
    {
      "name": "apoc.nodes.group",
      "signature": "apoc.nodes.group(labels :: LIST<STRING>, groupByProperties :: LIST<STRING>, aggregations = [{*=count}, {*=count}] :: LIST<MAP>, config = {} :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>, node :: NODE, relationship :: RELATIONSHIP)",
      "description": "Allows for the aggregation of `NODE` values based on the given properties.\nThis procedure returns virtual `NODE` values."
    },
    {
      "name": "apoc.nodes.link",
      "signature": "apoc.nodes.link(nodes :: LIST<NODE>, type :: STRING, config = {} :: MAP)",
      "description": "Creates a linked list of the given `NODE` values connected by the given `RELATIONSHIP` type."
    },
    {
      "name": "apoc.nodes.rels",
      "signature": "apoc.nodes.rels(rels :: ANY) :: (rel :: RELATIONSHIP)",
      "description": "Returns all `RELATIONSHIP` values with the given ids."
    },
    {
      "name": "apoc.path.expand",
      "signature": "apoc.path.expand(startNode :: ANY, relFilter :: STRING, labelFilter :: STRING, minDepth :: INTEGER, maxDepth :: INTEGER) :: (path :: PATH)",
      "description": "Returns `PATH` values expanded from the start `NODE` following the given `RELATIONSHIP` types from min-depth to max-depth."
    },
    {
      "name": "apoc.path.expandConfig",
      "signature": "apoc.path.expandConfig(startNode :: ANY, config :: MAP) :: (path :: PATH)",
      "description": "Returns `PATH` values expanded from the start `NODE` with the given `RELATIONSHIP` types from min-depth to max-depth."
    },
    {
      "name": "apoc.path.spanningTree",
      "signature": "apoc.path.spanningTree(startNode :: ANY, config :: MAP) :: (path :: PATH)",
      "description": "Returns spanning tree `PATH` values expanded from the start `NODE` following the given `RELATIONSHIP` types to max-depth."
    },
    {
      "name": "apoc.path.subgraphAll",
      "signature": "apoc.path.subgraphAll(startNode :: ANY, config :: MAP) :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)",
      "description": "Returns the sub-graph reachable from the start `NODE` following the given `RELATIONSHIP` types to max-depth."
    },
    {
      "name": "apoc.path.subgraphNodes",
      "signature": "apoc.path.subgraphNodes(startNode :: ANY, config :: MAP) :: (node :: NODE)",
      "description": "Returns the `NODE` values in the sub-graph reachable from the start `NODE` following the given `RELATIONSHIP` types to max-depth."
    },
    {
      "name": "apoc.paths.toJsonTree",
      "signature": "apoc.paths.toJsonTree(paths :: LIST<PATH>, lowerCaseRels = true :: BOOLEAN, config = {} :: MAP) :: (value :: MAP)",
      "description": "Creates a stream of nested documents representing the graph as a tree by traversing outgoing relationships."
    },
    {
      "name": "apoc.periodic.cancel",
      "signature": "apoc.periodic.cancel(name :: STRING) :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)",
      "description": "Cancels the given background job."
    },
    {
      "name": "apoc.periodic.commit",
      "signature": "apoc.periodic.commit(statement :: STRING, params = {} :: MAP) :: (updates :: INTEGER, executions :: INTEGER, runtime :: INTEGER, batches :: INTEGER, failedBatches :: INTEGER, batchErrors :: MAP, failedCommits :: INTEGER, commitErrors :: MAP, wasTerminated :: BOOLEAN)",
      "description": "Runs the given statement in separate batched transactions."
    },
    {
      "name": "apoc.periodic.countdown",
      "signature": "apoc.periodic.countdown(name :: STRING, statement :: STRING, delay :: INTEGER) :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)",
      "description": "Runs a repeatedly called background statement until it returns 0."
    },
    {
      "name": "apoc.periodic.iterate",
      "signature": "apoc.periodic.iterate(cypherIterate :: STRING, cypherAction :: STRING, config :: MAP) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, wasTerminated :: BOOLEAN, failedParams :: MAP, updateStatistics :: MAP)",
      "description": "Runs the second statement for each item returned by the first statement.\nThis procedure returns the number of batches and the total number of processed rows."
    },
    {
      "name": "apoc.periodic.list",
      "signature": "apoc.periodic.list() :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)",
      "description": "Returns a `LIST<ANY>` of all background jobs."
    },
    {
      "name": "apoc.periodic.repeat",
      "signature": "apoc.periodic.repeat(name :: STRING, statement :: STRING, rate :: INTEGER, config = {} :: MAP) :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)",
      "description": "Runs a repeatedly called background job. To stop this procedure, use `apoc.periodic.cancel`."
    },
    {
      "name": "apoc.periodic.submit",
      "signature": "apoc.periodic.submit(name :: STRING, statement :: STRING, params = {} :: MAP) :: (name :: STRING, delay :: INTEGER, rate :: INTEGER, done :: BOOLEAN, cancelled :: BOOLEAN)",
      "description": "Creates a background job which runs the given Cypher statement once."
    },
    {
      "name": "apoc.refactor.categorize",
      "signature": "apoc.refactor.categorize(sourceKey :: STRING, type :: STRING, outgoing :: BOOLEAN, label :: STRING, targetKey :: STRING, copiedKeys :: LIST<STRING>, batchSize :: INTEGER)",
      "description": "Creates new category `NODE` values from `NODE` values in the graph with the specified `sourceKey` as one of its property keys.\nThe new category `NODE` values are then connected to the original `NODE` values with a `RELATIONSHIP` of the given type."
    },
    {
      "name": "apoc.refactor.cloneNodes",
      "signature": "apoc.refactor.cloneNodes(nodes :: LIST<NODE>, withRelationships = false :: BOOLEAN, skipProperties = [] :: LIST<STRING>) :: (input :: INTEGER, output :: NODE, error :: STRING)",
      "description": "Clones the given `NODE` values with their labels and properties.\nIt is possible to skip any `NODE` properties using skipProperties (note: this only skips properties on `NODE` values and not their `RELATIONSHIP` values)."
    },
    {
      "name": "apoc.refactor.cloneSubgraph",
      "signature": "apoc.refactor.cloneSubgraph(nodes :: LIST<NODE>, rels = [] :: LIST<RELATIONSHIP>, config = {} :: MAP) :: (input :: INTEGER, output :: NODE, error :: STRING)",
      "description": "Clones the given `NODE` values with their labels and properties (optionally skipping any properties in the `skipProperties` `LIST<STRING>` via the config `MAP`), and clones the given `RELATIONSHIP` values.\nIf no `RELATIONSHIP` values are provided, all existing `RELATIONSHIP` values between the given `NODE` values will be cloned."
    },
    {
      "name": "apoc.refactor.cloneSubgraphFromPaths",
      "signature": "apoc.refactor.cloneSubgraphFromPaths(paths :: LIST<PATH>, config = {} :: MAP) :: (input :: INTEGER, output :: NODE, error :: STRING)",
      "description": "Clones a sub-graph defined by the given `LIST<PATH>` values.\nIt is possible to skip any `NODE` properties using the `skipProperties` `LIST<STRING>` via the config `MAP`."
    },
    {
      "name": "apoc.refactor.collapseNode",
      "signature": "apoc.refactor.collapseNode(nodes :: ANY, relType :: STRING) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)",
      "description": "Collapses the given `NODE` and replaces it with a `RELATIONSHIP` of the given type."
    },
    {
      "name": "apoc.refactor.extractNode",
      "signature": "apoc.refactor.extractNode(rels :: ANY, labels :: LIST<STRING>, outType :: STRING, inType :: STRING) :: (input :: INTEGER, output :: NODE, error :: STRING)",
      "description": "Expands the given `RELATIONSHIP` VALUES into intermediate `NODE` VALUES.\nThe intermediate `NODE` values are connected by the given `outType` and `inType`."
    },
    {
      "name": "apoc.refactor.from",
      "signature": "apoc.refactor.from(rel :: RELATIONSHIP, newNode :: NODE, config = {} :: MAP) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)",
      "description": "Redirects the given `RELATIONSHIP` to the given start `NODE`."
    },
    {
      "name": "apoc.refactor.invert",
      "signature": "apoc.refactor.invert(rel :: RELATIONSHIP, config = {} :: MAP) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)",
      "description": "Inverts the direction of the given `RELATIONSHIP`."
    },
    {
      "name": "apoc.refactor.mergeNodes",
      "signature": "apoc.refactor.mergeNodes(nodes :: LIST<NODE>, config = {} :: MAP) :: (node :: NODE)",
      "description": "Merges the given `LIST<NODE>` onto the first `NODE` in the `LIST<NODE>`.\nAll `RELATIONSHIP` values are merged onto that `NODE` as well."
    },
    {
      "name": "apoc.refactor.mergeRelationships",
      "signature": "apoc.refactor.mergeRelationships(rels :: LIST<RELATIONSHIP>, config = {} :: MAP) :: (rel :: RELATIONSHIP)",
      "description": "Merges the given `LIST<RELATIONSHIP>` onto the first `RELATIONSHIP` in the `LIST<RELATIONSHIP>`."
    },
    {
      "name": "apoc.refactor.normalizeAsBoolean",
      "signature": "apoc.refactor.normalizeAsBoolean(entity :: ANY, propertyKey :: STRING, trueValues :: LIST<ANY>, falseValues :: LIST<ANY>)",
      "description": "Refactors the given property to a `BOOLEAN`."
    },
    {
      "name": "apoc.refactor.rename.label",
      "signature": "apoc.refactor.rename.label(oldLabel :: STRING, newLabel :: STRING, nodes = [] :: LIST<NODE>) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, constraints :: LIST<STRING>, indexes :: LIST<STRING>)",
      "description": "Renames the given label from `oldLabel` to `newLabel` for all `NODE` values.\nIf a `LIST<NODE>` is provided, the renaming is applied to the `NODE` values within this `LIST<NODE>` only."
    },
    {
      "name": "apoc.refactor.rename.nodeProperty",
      "signature": "apoc.refactor.rename.nodeProperty(oldName :: STRING, newName :: STRING, nodes = [] :: LIST<NODE>, config = {} :: MAP) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, constraints :: LIST<STRING>, indexes :: LIST<STRING>)",
      "description": "Renames the given property from `oldName` to `newName` for all `NODE` values.\nIf a `LIST<NODE>` is provided, the renaming is applied to the `NODE` values within this `LIST<NODE>` only."
    },
    {
      "name": "apoc.refactor.rename.type",
      "signature": "apoc.refactor.rename.type(oldType :: STRING, newType :: STRING, rels = [] :: LIST<RELATIONSHIP>, config = {} :: MAP) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, constraints :: LIST<STRING>, indexes :: LIST<STRING>)",
      "description": "Renames all `RELATIONSHIP` values with type `oldType` to `newType`.\nIf a `LIST<RELATIONSHIP>` is provided, the renaming is applied to the `RELATIONSHIP` values within this `LIST<RELATIONSHIP>` only."
    },
    {
      "name": "apoc.refactor.rename.typeProperty",
      "signature": "apoc.refactor.rename.typeProperty(oldName :: STRING, newName :: STRING, rels = [] :: LIST<RELATIONSHIP>, config = {} :: MAP) :: (batches :: INTEGER, total :: INTEGER, timeTaken :: INTEGER, committedOperations :: INTEGER, failedOperations :: INTEGER, failedBatches :: INTEGER, retries :: INTEGER, errorMessages :: MAP, batch :: MAP, operations :: MAP, constraints :: LIST<STRING>, indexes :: LIST<STRING>)",
      "description": "Renames the given property from `oldName` to `newName` for all `RELATIONSHIP` values.\nIf a `LIST<RELATIONSHIP>` is provided, the renaming is applied to the `RELATIONSHIP` values within this `LIST<RELATIONSHIP>` only."
    },
    {
      "name": "apoc.refactor.setType",
      "signature": "apoc.refactor.setType(rel :: RELATIONSHIP, newType :: STRING) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)",
      "description": "Changes the type of the given `RELATIONSHIP`."
    },
    {
      "name": "apoc.refactor.to",
      "signature": "apoc.refactor.to(rel :: RELATIONSHIP, endNode :: NODE, config = {} :: MAP) :: (input :: INTEGER, output :: RELATIONSHIP, error :: STRING)",
      "description": "Redirects the given `RELATIONSHIP` to the given end `NODE`."
    },
    {
      "name": "apoc.schema.assert",
      "signature": "apoc.schema.assert(indexes :: MAP, constraints :: MAP, dropExisting = true :: BOOLEAN) :: (label :: ANY, key :: STRING, keys :: LIST<STRING>, unique :: BOOLEAN, action :: STRING)",
      "description": "Drops all other existing indexes and constraints when `dropExisting` is `true` (default is `true`).\nAsserts at the end of the operation that the given indexes and unique constraints are there."
    },
    {
      "name": "apoc.schema.nodes",
      "signature": "apoc.schema.nodes(config = {} :: MAP) :: (name :: STRING, label :: ANY, properties :: LIST<STRING>, status :: STRING, type :: STRING, failure :: STRING, populationProgress :: FLOAT, size :: INTEGER, valuesSelectivity :: FLOAT, userDescription :: STRING)",
      "description": "Returns all indexes and constraints information for all `NODE` labels in the database.\nIt is possible to define a set of labels to include or exclude in the config parameters."
    },
    {
      "name": "apoc.schema.properties.distinct",
      "signature": "apoc.schema.properties.distinct(label :: STRING, key :: STRING) :: (value :: LIST<ANY>)",
      "description": "Returns all distinct `NODE` property values for the given key."
    },
    {
      "name": "apoc.schema.properties.distinctCount",
      "signature": "apoc.schema.properties.distinctCount(label =  :: STRING, key =  :: STRING) :: (label :: STRING, key :: STRING, value :: ANY, count :: INTEGER)",
      "description": "Returns all distinct property values and counts for the given key."
    },
    {
      "name": "apoc.schema.relationships",
      "signature": "apoc.schema.relationships(config = {} :: MAP) :: (name :: STRING, type :: STRING, properties :: LIST<STRING>, status :: STRING, relationshipType :: ANY)",
      "description": "Returns the indexes and constraints information for all the relationship types in the database.\nIt is possible to define a set of relationship types to include or exclude in the config parameters."
    },
    {
      "name": "apoc.search.multiSearchReduced",
      "signature": "apoc.search.multiSearchReduced(labelPropertyMap :: ANY, operator :: STRING, value :: STRING) :: (id :: INTEGER, labels :: LIST<STRING>, values :: MAP)",
      "description": "Returns a reduced representation of the `NODE` values found after a parallel search over multiple indexes.\nThe reduced `NODE` values representation includes: node id, node labels, and the searched properties."
    },
    {
      "name": "apoc.search.node",
      "signature": "apoc.search.node(labelPropertyMap :: ANY, operator :: STRING, value :: STRING) :: (node :: NODE)",
      "description": "Returns all the distinct `NODE` values found after a parallel search over multiple indexes."
    },
    {
      "name": "apoc.search.nodeAll",
      "signature": "apoc.search.nodeAll(labelPropertyMap :: ANY, operator :: STRING, value :: STRING) :: (node :: NODE)",
      "description": "Returns all the `NODE` values found after a parallel search over multiple indexes."
    },
    {
      "name": "apoc.search.nodeAllReduced",
      "signature": "apoc.search.nodeAllReduced(labelPropertyMap :: ANY, operator :: STRING, value :: ANY) :: (id :: INTEGER, labels :: LIST<STRING>, values :: MAP)",
      "description": "Returns a reduced representation of the `NODE` values found after a parallel search over multiple indexes.\nThe reduced `NODE` values representation includes: node id, node labels, and the searched properties."
    },
    {
      "name": "apoc.search.nodeReduced",
      "signature": "apoc.search.nodeReduced(labelPropertyMap :: ANY, operator :: STRING, value :: STRING) :: (id :: INTEGER, labels :: LIST<STRING>, values :: MAP)",
      "description": "Returns a reduced representation of the distinct `NODE` values found after a parallel search over multiple indexes.\nThe reduced `NODE` values representation includes: node id, node labels, and the searched properties."
    },
    {
      "name": "apoc.spatial.geocode",
      "signature": "apoc.spatial.geocode(location :: STRING, maxResults = 100 :: INTEGER, quotaException = false :: BOOLEAN, config = {} :: MAP) :: (location :: MAP, data :: MAP, latitude :: FLOAT, longitude :: FLOAT, description :: STRING)",
      "description": "Returns the geographic location (latitude, longitude, and description) of the given address using a geocoding service (default: OpenStreetMap)."
    },
    {
      "name": "apoc.spatial.geocodeOnce",
      "signature": "apoc.spatial.geocodeOnce(location :: STRING, config = {} :: MAP) :: (location :: MAP, data :: MAP, latitude :: FLOAT, longitude :: FLOAT, description :: STRING)",
      "description": "Returns the geographic location (latitude, longitude, and description) of the given address using a geocoding service (default: OpenStreetMap).\nThis procedure returns at most one result."
    },
    {
      "name": "apoc.spatial.reverseGeocode",
      "signature": "apoc.spatial.reverseGeocode(latitude :: FLOAT, longitude :: FLOAT, quotaException = false :: BOOLEAN, config = {} :: MAP) :: (location :: MAP, data :: MAP, latitude :: FLOAT, longitude :: FLOAT, description :: STRING)",
      "description": "Returns a textual address from the given geographic location (latitude, longitude) using a geocoding service (default: OpenStreetMap).\nThis procedure returns at most one result."
    },
    {
      "name": "apoc.spatial.sortByDistance",
      "signature": "apoc.spatial.sortByDistance(paths :: LIST<PATH>) :: (path :: PATH, distance :: FLOAT)",
      "description": "Sorts the given collection of `PATH` values by the sum of their distance based on the latitude/longitude values in the `NODE` values."
    },
    {
      "name": "apoc.stats.degrees",
      "signature": "apoc.stats.degrees(relTypes =  :: STRING) :: (type :: STRING, direction :: STRING, total :: INTEGER, p50 :: INTEGER, p75 :: INTEGER, p90 :: INTEGER, p95 :: INTEGER, p99 :: INTEGER, p999 :: INTEGER, max :: INTEGER, min :: INTEGER, mean :: FLOAT)",
      "description": "Returns the percentile groupings of the degrees on the `NODE` values connected by the given `RELATIONSHIP` types."
    },
    {
      "name": "apoc.text.phoneticDelta",
      "signature": "apoc.text.phoneticDelta(text1 :: STRING, text2 :: STRING) :: (phonetic1 :: STRING, phonetic2 :: STRING, delta :: INTEGER)",
      "description": "Returns the US_ENGLISH soundex character difference between the two given `STRING` values."
    },
    {
      "name": "apoc.util.sleep",
      "signature": "apoc.util.sleep(duration :: INTEGER)",
      "description": "Causes the currently running Cypher to sleep for the given duration of milliseconds (the transaction termination is honored)."
    },
    {
      "name": "apoc.util.validate",
      "signature": "apoc.util.validate(predicate :: BOOLEAN, message :: STRING, params :: LIST<ANY>)",
      "description": "If the given predicate is true an exception is thrown."
    },
    {
      "name": "apoc.warmup.run",
      "signature": "apoc.warmup.run(loadProperties = false :: BOOLEAN, loadDynamicProperties = false :: BOOLEAN, loadIndexes = false :: BOOLEAN) :: (pageSize :: INTEGER, totalTime :: INTEGER, transactionWasTerminated :: BOOLEAN, nodesPerPage :: INTEGER, nodesTotal :: INTEGER, nodePages :: INTEGER, nodesTime :: INTEGER, relsPerPage :: INTEGER, relsTotal :: INTEGER, relPages :: INTEGER, relsTime :: INTEGER, relGroupsPerPage :: INTEGER, relGroupsTotal :: INTEGER, relGroupPages :: INTEGER, relGroupsTime :: INTEGER, propertiesLoaded :: BOOLEAN, dynamicPropertiesLoaded :: BOOLEAN, propsPerPage :: INTEGER, propRecordsTotal :: INTEGER, propPages :: INTEGER, propsTime :: INTEGER, stringPropsPerPage :: INTEGER, stringPropRecordsTotal :: INTEGER, stringPropPages :: INTEGER, stringPropsTime :: INTEGER, arrayPropsPerPage :: INTEGER, arrayPropRecordsTotal :: INTEGER, arrayPropPages :: INTEGER, arrayPropsTime :: INTEGER, indexesLoaded :: BOOLEAN, indexPages :: INTEGER, indexTime :: INTEGER)",
      "description": "Loads all `NODE` and `RELATIONSHIP` values in the database into memory."
    },
    {
      "name": "apoc.when",
      "signature": "apoc.when(condition :: BOOLEAN, ifQuery :: STRING, elseQuery =  :: STRING, params = {} :: MAP) :: (value :: MAP)",
      "description": "This procedure will run the read-only `ifQuery` if the conditional has evaluated to true, otherwise the `elseQuery` will run."
    },
    {
      "name": "cdc.current",
      "signature": "cdc.current() :: (id :: STRING)",
      "description": "Returns the current change identifier that can be used to stream changes from."
    },
    {
      "name": "cdc.earliest",
      "signature": "cdc.earliest() :: (id :: STRING)",
      "description": "Returns the earliest change identifier that can be used to stream changes from."
    },
    {
      "name": "cdc.query",
      "signature": "cdc.query(from =  :: STRING, selectors = [] :: LIST<MAP>) :: (id :: STRING, txId :: INTEGER, seq :: INTEGER, metadata :: MAP, event :: MAP)",
      "description": "Query changes happened from the provided change identifier."
    },
    {
      "name": "db.awaitIndex",
      "signature": "db.awaitIndex(indexName :: STRING, timeOutSeconds = 300 :: INTEGER)",
      "description": "Wait for an index to come online (for example: CALL db.awaitIndex(\"MyIndex\", 300))."
    },
    {
      "name": "db.awaitIndexes",
      "signature": "db.awaitIndexes(timeOutSeconds = 300 :: INTEGER)",
      "description": "Wait for all indexes to come online (for example: CALL db.awaitIndexes(300))."
    },
    {
      "name": "db.cdc.current",
      "signature": "db.cdc.current() :: (id :: STRING)",
      "description": "Returns the current change identifier that can be used to stream changes from."
    },
    {
      "name": "db.cdc.earliest",
      "signature": "db.cdc.earliest() :: (id :: STRING)",
      "description": "Returns the earliest change identifier that can be used to stream changes from."
    },
    {
      "name": "db.cdc.query",
      "signature": "db.cdc.query(from =  :: STRING, selectors = [] :: LIST<MAP>) :: (id :: STRING, txId :: INTEGER, seq :: INTEGER, metadata :: MAP, event :: MAP)",
      "description": "Query changes happened from the provided change identifier."
    },
    {
      "name": "db.cdc.translateId",
      "signature": "db.cdc.translateId(from :: STRING) :: (id :: STRING)",
      "description": "Translate any provided change identifier to match the queried database."
    },
    {
      "name": "db.checkpoint",
      "signature": "db.checkpoint() :: (success :: BOOLEAN, message :: STRING)",
      "description": "Initiate and wait for a new check point, or wait any already on-going check point to complete. Note that this temporarily disables the `db.checkpoint.iops.limit` setting in order to make the check point complete faster. This might cause transaction throughput to degrade slightly, due to increased IO load."
    },
    {
      "name": "db.clearQueryCaches",
      "signature": "db.clearQueryCaches() :: (value :: STRING)",
      "description": "Clears all query caches."
    },
    {
      "name": "db.create.setNodeVectorProperty",
      "signature": "db.create.setNodeVectorProperty(node :: NODE, key :: STRING, vector :: ANY)",
      "description": "Set a vector property on a given node in a more space efficient representation than Cypher's SET."
    },
    {
      "name": "db.create.setRelationshipVectorProperty",
      "signature": "db.create.setRelationshipVectorProperty(relationship :: RELATIONSHIP, key :: STRING, vector :: ANY)",
      "description": "Set a vector property on a given relationship in a more space efficient representation than Cypher's SET."
    },
    {
      "name": "db.create.setVectorProperty",
      "signature": "db.create.setVectorProperty(node :: NODE, key :: STRING, vector :: ANY) :: (node :: NODE)",
      "description": "Set a vector property on a given node in a more space efficient representation than Cypher's SET."
    },
    {
      "name": "db.createLabel",
      "signature": "db.createLabel(newLabel :: STRING)",
      "description": "Create a label"
    },
    {
      "name": "db.createProperty",
      "signature": "db.createProperty(newProperty :: STRING)",
      "description": "Create a Property"
    },
    {
      "name": "db.createRelationshipType",
      "signature": "db.createRelationshipType(newRelationshipType :: STRING)",
      "description": "Create a RelationshipType"
    },
    {
      "name": "db.index.fulltext.awaitEventuallyConsistentIndexRefresh",
      "signature": "db.index.fulltext.awaitEventuallyConsistentIndexRefresh()",
      "description": "Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes."
    },
    {
      "name": "db.index.fulltext.listAvailableAnalyzers",
      "signature": "db.index.fulltext.listAvailableAnalyzers() :: (analyzer :: STRING, description :: STRING, stopwords :: LIST<STRING>)",
      "description": "List the available analyzers that the full-text indexes can be configured with."
    },
    {
      "name": "db.index.fulltext.queryNodes",
      "signature": "db.index.fulltext.queryNodes(indexName :: STRING, queryString :: STRING, options = {} :: MAP) :: (node :: NODE, score :: FLOAT)",
      "description": "Query the given full-text index. Returns the matching nodes and their Lucene query score, ordered by score.\nValid _key: value_ pairs for the `options` map are:\n\n* 'skip' -- to skip the top N results.\n* 'limit' -- to limit the number of results returned.\n* 'analyzer' -- to use the specified analyzer as a search analyzer for this query.\n\nThe `options` map and any of the keys are optional.\nAn example of the `options` map: `{skip: 30, limit: 10, analyzer: 'whitespace'}`\n"
    },
    {
      "name": "db.index.fulltext.queryRelationships",
      "signature": "db.index.fulltext.queryRelationships(indexName :: STRING, queryString :: STRING, options = {} :: MAP) :: (relationship :: RELATIONSHIP, score :: FLOAT)",
      "description": "Query the given full-text index. Returns the matching relationships and their Lucene query score, ordered by score.\nValid _key: value_ pairs for the `options` map are:\n\n* 'skip' -- to skip the top N results.\n* 'limit' -- to limit the number of results returned.\n* 'analyzer' -- to use the specified analyzer as a search analyzer for this query.\n\nThe `options` map and any of the keys are optional.\nAn example of the `options` map: `{skip: 30, limit: 10, analyzer: 'whitespace'}`\n"
    },
    {
      "name": "db.index.vector.createNodeIndex",
      "signature": "db.index.vector.createNodeIndex(indexName :: STRING, label :: STRING, propertyKey :: STRING, vectorDimension :: INTEGER, vectorSimilarityFunction :: STRING)",
      "description": "Create a named node vector index for the specified label and property with the given vector dimensionality using either the EUCLIDEAN or COSINE similarity function.\nBoth similarity functions are case-insensitive.\nUse the `db.index.vector.queryNodes` procedure to query the named index.\n"
    },
    {
      "name": "db.index.vector.queryNodes",
      "signature": "db.index.vector.queryNodes(indexName :: STRING, numberOfNearestNeighbours :: INTEGER, query :: ANY) :: (node :: NODE, score :: FLOAT)",
      "description": "Query the given node vector index.\nReturns requested number of nearest neighbors to the provided query vector,\nand their similarity score to that query vector, based on the configured similarity function for the index.\nThe similarity score is a value between [0, 1]; where 0 indicates least similar, 1 most similar.\n"
    },
    {
      "name": "db.index.vector.queryRelationships",
      "signature": "db.index.vector.queryRelationships(indexName :: STRING, numberOfNearestNeighbours :: INTEGER, query :: ANY) :: (relationship :: RELATIONSHIP, score :: FLOAT)",
      "description": "Query the given relationship vector index.\nReturns requested number of nearest neighbors to the provided query vector,\nand their similarity score to that query vector, based on the configured similarity function for the index.\nThe similarity score is a value between [0, 1]; where 0 indicates least similar, 1 most similar.\n"
    },
    {
      "name": "db.info",
      "signature": "db.info() :: (id :: STRING, name :: STRING, creationDate :: STRING)",
      "description": "Provides information regarding the database."
    },
    {
      "name": "db.labels",
      "signature": "db.labels() :: (label :: STRING)",
      "description": "List all labels attached to nodes within a database according to the user's access rights. The procedure returns empty results if the user is not authorized to view those labels."
    },
    {
      "name": "db.listLocks",
      "signature": "db.listLocks() :: (mode :: STRING, resourceType :: STRING, resourceId :: INTEGER, transactionId :: STRING)",
      "description": "List all locks at this database."
    },
    {
      "name": "db.ping",
      "signature": "db.ping() :: (success :: BOOLEAN)",
      "description": "This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure."
    },
    {
      "name": "db.prepareForReplanning",
      "signature": "db.prepareForReplanning(timeOutSeconds = 300 :: INTEGER)",
      "description": "Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics."
    },
    {
      "name": "db.propertyKeys",
      "signature": "db.propertyKeys() :: (propertyKey :: STRING)",
      "description": "List all property keys in the database."
    },
    {
      "name": "db.relationshipTypes",
      "signature": "db.relationshipTypes() :: (relationshipType :: STRING)",
      "description": "List all types attached to relationships within a database according to the user's access rights. The procedure returns empty results if the user is not authorized to view those relationship types."
    },
    {
      "name": "db.resampleIndex",
      "signature": "db.resampleIndex(indexName :: STRING)",
      "description": "Schedule resampling of an index (for example: CALL db.resampleIndex(\"MyIndex\"))."
    },
    {
      "name": "db.resampleOutdatedIndexes",
      "signature": "db.resampleOutdatedIndexes()",
      "description": "Schedule resampling of all outdated indexes."
    },
    {
      "name": "db.schema.nodeTypeProperties",
      "signature": "db.schema.nodeTypeProperties() :: (nodeType :: STRING, nodeLabels :: LIST<STRING>, propertyName :: STRING, propertyTypes :: LIST<STRING>, mandatory :: BOOLEAN)",
      "description": "Show the derived property schema of the nodes in tabular form."
    },
    {
      "name": "db.schema.relTypeProperties",
      "signature": "db.schema.relTypeProperties() :: (relType :: STRING, propertyName :: STRING, propertyTypes :: LIST<STRING>, mandatory :: BOOLEAN)",
      "description": "Show the derived property schema of the relationships in tabular form."
    },
    {
      "name": "db.schema.visualization",
      "signature": "db.schema.visualization() :: (nodes :: LIST<NODE>, relationships :: LIST<RELATIONSHIP>)",
      "description": "Visualizes the schema of the data based on available statistics. A new node is returned for each label. The properties represented on the node include: `name` (label name), `indexes` (list of indexes), and `constraints` (list of constraints). A relationship of a given type is returned for all possible combinations of start and end nodes. The properties represented on the relationship include: `name` (type name). Note that this may include additional relationships that do not exist in the data due to the information available in the count store. "
    },
    {
      "name": "db.stats.clear",
      "signature": "db.stats.clear(section :: STRING) :: (section :: STRING, success :: BOOLEAN, message :: STRING)",
      "description": "Clear collected data of a given data section. Valid sections are 'QUERIES'"
    },
    {
      "name": "db.stats.collect",
      "signature": "db.stats.collect(section :: STRING, config = {} :: MAP) :: (section :: STRING, success :: BOOLEAN, message :: STRING)",
      "description": "Start data collection of a given data section. Valid sections are 'QUERIES'"
    },
    {
      "name": "db.stats.retrieve",
      "signature": "db.stats.retrieve(section :: STRING, config = {} :: MAP) :: (section :: STRING, data :: MAP)",
      "description": "Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META'"
    },
    {
      "name": "db.stats.retrieveAllAnonymized",
      "signature": "db.stats.retrieveAllAnonymized(graphToken :: STRING, config = {} :: MAP) :: (section :: STRING, data :: MAP)",
      "description": "Retrieve all available statistical data about the current database, in an anonymized form."
    },
    {
      "name": "db.stats.status",
      "signature": "db.stats.status() :: (section :: STRING, status :: STRING, data :: MAP)",
      "description": "Retrieve the status of all available collector daemons, for this database."
    },
    {
      "name": "db.stats.stop",
      "signature": "db.stats.stop(section :: STRING) :: (section :: STRING, success :: BOOLEAN, message :: STRING)",
      "description": "Stop data collection of a given data section. Valid sections are 'QUERIES'"
    },
    {
      "name": "dbms.checkConfigValue",
      "signature": "dbms.checkConfigValue(setting :: STRING, value :: STRING) :: (valid :: BOOLEAN, message :: STRING)",
      "description": "Check if a potential config setting value is valid."
    },
    {
      "name": "dbms.cluster.checkConnectivity",
      "signature": "dbms.cluster.checkConnectivity(port-name = null :: STRING, server = null :: STRING) :: (serverId :: STRING, name :: STRING, address :: STRING, mode-constraint :: STRING, port-name :: STRING, port-address :: STRING, result :: STRING)",
      "description": "Check the connectivity of this instance to other cluster members. Not all ports are relevant to all members. Valid values for 'port-name' are: [CLUSTER, INTRA_BOLT, RAFT]"
    },
    {
      "name": "dbms.cluster.cordonServer",
      "signature": "dbms.cluster.cordonServer(server :: STRING)",
      "description": "Mark a server in the topology as not suitable for new allocations. It will not force current allocations off the server. This is useful when deallocating databases when you have multiple unavailable servers."
    },
    {
      "name": "dbms.cluster.deallocateDatabaseFromServer",
      "signature": "dbms.cluster.deallocateDatabaseFromServer(server :: STRING, database :: STRING, dryrun = false :: BOOLEAN) :: (database :: STRING, fromServerName :: STRING, fromServerId :: STRING, toServerName :: STRING, toServerId :: STRING, mode :: STRING)",
      "description": "Deallocate a specific user database from a specific server."
    },
    {
      "name": "dbms.cluster.deallocateDatabaseFromServers",
      "signature": "dbms.cluster.deallocateDatabaseFromServers(servers :: LIST<STRING>, database :: STRING, dryrun = false :: BOOLEAN) :: (database :: STRING, fromServerName :: STRING, fromServerId :: STRING, toServerName :: STRING, toServerId :: STRING, mode :: STRING)",
      "description": "Deallocate a specific user database from a list of servers."
    },
    {
      "name": "dbms.cluster.deallocateNumberOfDatabases",
      "signature": "dbms.cluster.deallocateNumberOfDatabases(server :: STRING, number :: INTEGER, dryrun = false :: BOOLEAN) :: (database :: STRING, fromServerName :: STRING, fromServerId :: STRING, toServerName :: STRING, toServerId :: STRING, mode :: STRING)",
      "description": "Deallocate a number of user databases from a specific server."
    },
    {
      "name": "dbms.cluster.protocols",
      "signature": "dbms.cluster.protocols() :: (orientation :: STRING, remoteAddress :: STRING, applicationProtocol :: STRING, applicationProtocolVersion :: INTEGER, modifierProtocols :: STRING)",
      "description": "Overview of installed protocols"
    },
    {
      "name": "dbms.cluster.readReplicaToggle",
      "signature": "dbms.cluster.readReplicaToggle(databaseName :: STRING, pause :: BOOLEAN) :: (state :: STRING)",
      "description": "The toggle can pause or resume read replica (deprecated in favor of dbms.cluster.secondaryReplicationDisable)"
    },
    {
      "name": "dbms.cluster.reallocateDatabase",
      "signature": "dbms.cluster.reallocateDatabase(database :: STRING, dryrun = false :: BOOLEAN) :: (database :: STRING, fromServerName :: STRING, fromServerId :: STRING, toServerName :: STRING, toServerId :: STRING, mode :: STRING)",
      "description": "Reallocate a specific database."
    },
    {
      "name": "dbms.cluster.reallocateNumberOfDatabases",
      "signature": "dbms.cluster.reallocateNumberOfDatabases(number :: INTEGER, dryrun = false :: BOOLEAN) :: (database :: STRING, fromServerName :: STRING, fromServerId :: STRING, toServerName :: STRING, toServerId :: STRING, mode :: STRING)",
      "description": "Reallocate a specified number of user databases."
    },
    {
      "name": "dbms.cluster.recreateDatabase",
      "signature": "dbms.cluster.recreateDatabase(database :: STRING, options = {} :: MAP)",
      "description": "Recreates a database while keeping all RBAC settings. The procedure initiates a process, which when complete, will have synchronized and started all database instances within the cluster."
    },
    {
      "name": "dbms.cluster.routing.getRoutingTable",
      "signature": "dbms.cluster.routing.getRoutingTable(context :: MAP, database = null :: STRING) :: (ttl :: INTEGER, servers :: LIST<MAP>)",
      "description": "Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example, an endpoint may serve read queries, write queries, and/or future `getRoutingTable` requests."
    },
    {
      "name": "dbms.cluster.secondaryReplicationDisable",
      "signature": "dbms.cluster.secondaryReplicationDisable(databaseName :: STRING, pause :: BOOLEAN) :: (state :: STRING)",
      "description": "The toggle can pause or resume the secondary replication process."
    },
    {
      "name": "dbms.cluster.setAutomaticallyEnableFreeServers",
      "signature": "dbms.cluster.setAutomaticallyEnableFreeServers(autoEnable :: BOOLEAN)",
      "description": "With this method you can set whether free servers are automatically enabled."
    },
    {
      "name": "dbms.cluster.statusCheck",
      "signature": "dbms.cluster.statusCheck(databases :: LIST<STRING>, timeoutMilliseconds = null :: INTEGER) :: (database :: STRING, serverId :: STRING, serverName :: STRING, address :: STRING, replicationSuccessful :: BOOLEAN, memberStatus :: STRING, recognisedLeader :: STRING, recognisedLeaderTerm :: INTEGER, requester :: BOOLEAN, error :: STRING)",
      "description": "Performs a rafted status check."
    },
    {
      "name": "dbms.cluster.uncordonServer",
      "signature": "dbms.cluster.uncordonServer(server :: STRING)",
      "description": "Remove the cordon on a server, returning it to 'enabled'."
    },
    {
      "name": "dbms.components",
      "signature": "dbms.components() :: (name :: STRING, versions :: LIST<STRING>, edition :: STRING)",
      "description": "List DBMS components and their versions."
    },
    {
      "name": "dbms.info",
      "signature": "dbms.info() :: (id :: STRING, name :: STRING, creationDate :: STRING)",
      "description": "Provides information regarding the DBMS."
    },
    {
      "name": "dbms.killConnection",
      "signature": "dbms.killConnection(id :: STRING) :: (connectionId :: STRING, username :: STRING, message :: STRING)",
      "description": "Kill network connection with the given connection id."
    },
    {
      "name": "dbms.killConnections",
      "signature": "dbms.killConnections(ids :: LIST<STRING>) :: (connectionId :: STRING, username :: STRING, message :: STRING)",
      "description": "Kill all network connections with the given connection ids."
    },
    {
      "name": "dbms.listActiveLocks",
      "signature": "dbms.listActiveLocks(queryId :: STRING) :: (mode :: STRING, resourceType :: STRING, resourceId :: INTEGER)",
      "description": "List the active lock requests granted for the transaction executing the query with the given query id."
    },
    {
      "name": "dbms.listCapabilities",
      "signature": "dbms.listCapabilities() :: (name :: STRING, description :: STRING, value :: ANY)",
      "description": "List capabilities."
    },
    {
      "name": "dbms.listConfig",
      "signature": "dbms.listConfig(searchString =  :: STRING) :: (name :: STRING, description :: STRING, value :: STRING, dynamic :: BOOLEAN, defaultValue :: STRING, startupValue :: STRING, explicitlySet :: BOOLEAN, validValues :: STRING)",
      "description": "List the currently active configuration settings of Neo4j."
    },
    {
      "name": "dbms.listConnections",
      "signature": "dbms.listConnections() :: (connectionId :: STRING, connectTime :: STRING, connector :: STRING, username :: STRING, userAgent :: STRING, serverAddress :: STRING, clientAddress :: STRING)",
      "description": "List all accepted network connections at this instance that are visible to the user."
    },
    {
      "name": "dbms.listPools",
      "signature": "dbms.listPools() :: (pool :: STRING, databaseName :: STRING, heapMemoryUsed :: STRING, heapMemoryUsedBytes :: STRING, nativeMemoryUsed :: STRING, nativeMemoryUsedBytes :: STRING, freeMemory :: STRING, freeMemoryBytes :: STRING, totalPoolMemory :: STRING, totalPoolMemoryBytes :: STRING)",
      "description": "List all memory pools, including sub pools, currently registered at this instance that are visible to the user."
    },
    {
      "name": "dbms.quarantineDatabase",
      "signature": "dbms.quarantineDatabase(databaseName :: STRING, setStatus :: BOOLEAN, reason = No reason given :: STRING) :: (databaseName :: STRING, quarantined :: BOOLEAN, result :: STRING)",
      "description": "Place a database into quarantine or remove it from it."
    },
    {
      "name": "dbms.queryJmx",
      "signature": "dbms.queryJmx(query :: STRING) :: (name :: STRING, description :: STRING, attributes :: MAP)",
      "description": "Query JMX management data by domain and name. For instance, use `*:*` to find all JMX beans."
    },
    {
      "name": "dbms.recreateDatabase",
      "signature": "dbms.recreateDatabase(database :: STRING, options = {} :: MAP)",
      "description": "Recreates a database while keeping all RBAC settings. The procedure initiates a process, which when complete, will have synchronized and started all database instances within the cluster."
    },
    {
      "name": "dbms.routing.getRoutingTable",
      "signature": "dbms.routing.getRoutingTable(context :: MAP, database = null :: STRING) :: (ttl :: INTEGER, servers :: LIST<MAP>)",
      "description": "Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example, an endpoint may serve read queries, write queries, and/or future `getRoutingTable` requests."
    },
    {
      "name": "dbms.scheduler.failedJobs",
      "signature": "dbms.scheduler.failedJobs() :: (jobId :: STRING, group :: STRING, database :: STRING, submitter :: STRING, description :: STRING, type :: STRING, submitted :: STRING, executionStart :: STRING, failureTime :: STRING, failureDescription :: STRING)",
      "description": "List failed job runs. There is a limit for amount of historical data."
    },
    {
      "name": "dbms.scheduler.groups",
      "signature": "dbms.scheduler.groups() :: (group :: STRING, threads :: INTEGER)",
      "description": "List the job groups that are active in the database internal job scheduler."
    },
    {
      "name": "dbms.scheduler.jobs",
      "signature": "dbms.scheduler.jobs() :: (jobId :: STRING, group :: STRING, submitted :: STRING, database :: STRING, submitter :: STRING, description :: STRING, type :: STRING, scheduledAt :: STRING, period :: STRING, state :: STRING, currentStateDescription :: STRING)",
      "description": "List all jobs that are active in the database internal job scheduler."
    },
    {
      "name": "dbms.security.clearAuthCache",
      "signature": "dbms.security.clearAuthCache()",
      "description": "Clears authentication and authorization cache."
    },
    {
      "name": "dbms.security.reloadTLS",
      "signature": "dbms.security.reloadTLS()",
      "description": "Trigger the dynamic reloading of all TLS certificates and configuration."
    },
    {
      "name": "dbms.setConfigValue",
      "signature": "dbms.setConfigValue(setting :: STRING, value :: STRING)",
      "description": "Update a given setting value. Passing an empty value results in removing the configured value and falling back to the default value. Changes do not persist and are lost if the server is restarted. In a clustered environment, `dbms.setConfigValue` affects only the cluster member it is run against."
    },
    {
      "name": "dbms.setDefaultAllocationNumbers",
      "signature": "dbms.setDefaultAllocationNumbers(primaries :: INTEGER, secondaries :: INTEGER)",
      "description": "With this method you can set the default number of primaries and secondaries."
    },
    {
      "name": "dbms.setDefaultDatabase",
      "signature": "dbms.setDefaultDatabase(databaseName :: STRING) :: (result :: STRING)",
      "description": "Change the default database to the provided value. The database must exist and the old default database must be stopped."
    },
    {
      "name": "dbms.showCurrentUser",
      "signature": "dbms.showCurrentUser() :: (username :: STRING, roles :: LIST<STRING>, flags :: LIST<STRING>)",
      "description": "Show the current user."
    },
    {
      "name": "dbms.showTopologyGraphConfig",
      "signature": "dbms.showTopologyGraphConfig() :: (allocator :: STRING, defaultPrimariesCount :: INTEGER, defaultSecondariesCount :: INTEGER, defaultDatabase :: STRING, autoEnableFreeServers :: BOOLEAN)",
      "description": "With this method the configuration of the Topology Graph can be displayed."
    },
    {
      "name": "dbms.unquarantineDatabase",
      "signature": "dbms.unquarantineDatabase(server :: STRING, database :: STRING, operation = keepStateKeepStore :: STRING)",
      "description": "Lift quarantine from a database on a given server."
    },
    {
      "name": "dbms.upgrade",
      "signature": "dbms.upgrade() :: (status :: STRING, upgradeResult :: STRING)",
      "description": "Upgrade the system database schema if it is not the current schema."
    },
    {
      "name": "dbms.upgradeStatus",
      "signature": "dbms.upgradeStatus() :: (status :: STRING, description :: STRING, resolution :: STRING)",
      "description": "Report the current status of the system database sub-graph schema."
    },
    {
      "name": "gds.allShortestPaths.delta.mutate",
      "signature": "gds.allShortestPaths.delta.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded"
    },
    {
      "name": "gds.allShortestPaths.delta.mutate.estimate",
      "signature": "gds.allShortestPaths.delta.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.allShortestPaths.delta.stats",
      "signature": "gds.allShortestPaths.delta.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded"
    },
    {
      "name": "gds.allShortestPaths.delta.stats.estimate",
      "signature": "gds.allShortestPaths.delta.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.allShortestPaths.delta.stream",
      "signature": "gds.allShortestPaths.delta.stream(graphName :: STRING, configuration = {} :: MAP) :: (index :: INTEGER, sourceNode :: INTEGER, targetNode :: INTEGER, totalCost :: FLOAT, nodeIds :: LIST<INTEGER>, costs :: LIST<FLOAT>, path :: PATH)",
      "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded"
    },
    {
      "name": "gds.allShortestPaths.delta.stream.estimate",
      "signature": "gds.allShortestPaths.delta.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.allShortestPaths.delta.write",
      "signature": "gds.allShortestPaths.delta.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded"
    },
    {
      "name": "gds.allShortestPaths.delta.write.estimate",
      "signature": "gds.allShortestPaths.delta.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.allShortestPaths.dijkstra.mutate",
      "signature": "gds.allShortestPaths.dijkstra.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph."
    },
    {
      "name": "gds.allShortestPaths.dijkstra.mutate.estimate",
      "signature": "gds.allShortestPaths.dijkstra.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.allShortestPaths.dijkstra.stream",
      "signature": "gds.allShortestPaths.dijkstra.stream(graphName :: STRING, configuration = {} :: MAP) :: (index :: INTEGER, sourceNode :: INTEGER, targetNode :: INTEGER, totalCost :: FLOAT, nodeIds :: LIST<INTEGER>, costs :: LIST<FLOAT>, path :: PATH)",
      "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph."
    },
    {
      "name": "gds.allShortestPaths.dijkstra.stream.estimate",
      "signature": "gds.allShortestPaths.dijkstra.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.allShortestPaths.dijkstra.write",
      "signature": "gds.allShortestPaths.dijkstra.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph."
    },
    {
      "name": "gds.allShortestPaths.dijkstra.write.estimate",
      "signature": "gds.allShortestPaths.dijkstra.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.articleRank.mutate",
      "signature": "gds.articleRank.mutate(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.articleRank.mutate.estimate",
      "signature": "gds.articleRank.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.articleRank.stats",
      "signature": "gds.articleRank.stats(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.articleRank.stats.estimate",
      "signature": "gds.articleRank.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.articleRank.stream",
      "signature": "gds.articleRank.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, score :: FLOAT)",
      "description": "Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.articleRank.stream.estimate",
      "signature": "gds.articleRank.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.articleRank.write",
      "signature": "gds.articleRank.write(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.articleRank.write.estimate",
      "signature": "gds.articleRank.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.articulationPoints.mutate",
      "signature": "gds.articulationPoints.mutate(graphName :: STRING, configuration = {} :: MAP) :: (articulationPointCount :: INTEGER, nodePropertiesWritten :: INTEGER, mutateMillis :: INTEGER, computeMillis :: INTEGER, configuration :: MAP)",
      "description": "Algorithm that finds nodes that disconnect components if removed"
    },
    {
      "name": "gds.articulationPoints.mutate.estimate",
      "signature": "gds.articulationPoints.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.articulationPoints.stats",
      "signature": "gds.articulationPoints.stats(graphName :: STRING, configuration = {} :: MAP) :: (articulationPointCount :: INTEGER, computeMillis :: INTEGER, configuration :: MAP)",
      "description": "Algorithm that finds nodes that disconnect components if removed"
    },
    {
      "name": "gds.articulationPoints.stats.estimate",
      "signature": "gds.articulationPoints.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.articulationPoints.stream",
      "signature": "gds.articulationPoints.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, resultingComponents :: MAP)",
      "description": "Algorithm that finds nodes that disconnect components if removed"
    },
    {
      "name": "gds.articulationPoints.stream.estimate",
      "signature": "gds.articulationPoints.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.articulationPoints.write",
      "signature": "gds.articulationPoints.write(graphName :: STRING, configuration = {} :: MAP) :: (articulationPointCount :: INTEGER, nodePropertiesWritten :: INTEGER, writeMillis :: INTEGER, computeMillis :: INTEGER, configuration :: MAP)",
      "description": "Algorithm that finds nodes that disconnect components if removed"
    },
    {
      "name": "gds.articulationPoints.write.estimate",
      "signature": "gds.articulationPoints.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.bellmanFord.mutate",
      "signature": "gds.bellmanFord.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP, containsNegativeCycle :: BOOLEAN, relationshipsWritten :: INTEGER)",
      "description": "The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph without negative cycles."
    },
    {
      "name": "gds.bellmanFord.mutate.estimate",
      "signature": "gds.bellmanFord.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.bellmanFord.stats",
      "signature": "gds.bellmanFord.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP, containsNegativeCycle :: BOOLEAN)",
      "description": "The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph without negative cycles."
    },
    {
      "name": "gds.bellmanFord.stats.estimate",
      "signature": "gds.bellmanFord.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.bellmanFord.stream",
      "signature": "gds.bellmanFord.stream(graphName :: STRING, configuration = {} :: MAP) :: (index :: INTEGER, sourceNode :: INTEGER, targetNode :: INTEGER, totalCost :: FLOAT, nodeIds :: LIST<INTEGER>, costs :: LIST<FLOAT>, route :: PATH, isNegativeCycle :: BOOLEAN)",
      "description": "The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph without negative cycles."
    },
    {
      "name": "gds.bellmanFord.stream.estimate",
      "signature": "gds.bellmanFord.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.bellmanFord.write",
      "signature": "gds.bellmanFord.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, postProcessingMillis :: INTEGER, relationshipsWritten :: INTEGER, containsNegativeCycle :: BOOLEAN, configuration :: MAP)",
      "description": "The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph without negative cycles."
    },
    {
      "name": "gds.bellmanFord.write.estimate",
      "signature": "gds.bellmanFord.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.betweenness.mutate",
      "signature": "gds.betweenness.mutate(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, centralityDistribution :: MAP, configuration :: MAP)",
      "description": "Betweenness centrality measures the relative information flow that passes through a node."
    },
    {
      "name": "gds.betweenness.mutate.estimate",
      "signature": "gds.betweenness.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.betweenness.stats",
      "signature": "gds.betweenness.stats(graphName :: STRING, configuration = {} :: MAP) :: (centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Betweenness centrality measures the relative information flow that passes through a node."
    },
    {
      "name": "gds.betweenness.stats.estimate",
      "signature": "gds.betweenness.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.betweenness.stream",
      "signature": "gds.betweenness.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, score :: FLOAT)",
      "description": "Betweenness centrality measures the relative information flow that passes through a node."
    },
    {
      "name": "gds.betweenness.stream.estimate",
      "signature": "gds.betweenness.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.betweenness.write",
      "signature": "gds.betweenness.write(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, centralityDistribution :: MAP, configuration :: MAP)",
      "description": "Betweenness centrality measures the relative information flow that passes through a node."
    },
    {
      "name": "gds.betweenness.write.estimate",
      "signature": "gds.betweenness.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.cliqueCounting.mutate",
      "signature": "gds.cliqueCounting.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, globalCount :: LIST<INTEGER>, configuration :: MAP)",
      "description": "The Clique Counting algorithm count the number of cliques of each size for every node in the graph."
    },
    {
      "name": "gds.cliqueCounting.mutate.estimate",
      "signature": "gds.cliqueCounting.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.cliqueCounting.stats",
      "signature": "gds.cliqueCounting.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, globalCount :: LIST<INTEGER>, configuration :: MAP)",
      "description": "The Clique Counting algorithm count the number of cliques of each size for every node in the graph."
    },
    {
      "name": "gds.cliqueCounting.stats.estimate",
      "signature": "gds.cliqueCounting.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.cliqueCounting.stream",
      "signature": "gds.cliqueCounting.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, counts :: LIST<INTEGER>)",
      "description": "The Clique Counting algorithm count the number of cliques of each size for every node in the graph."
    },
    {
      "name": "gds.cliqueCounting.stream.estimate",
      "signature": "gds.cliqueCounting.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.cliqueCounting.write",
      "signature": "gds.cliqueCounting.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, globalCount :: LIST<INTEGER>, configuration :: MAP)",
      "description": "The Clique Counting algorithm count the number of cliques of each size for every node in the graph."
    },
    {
      "name": "gds.cliqueCounting.write.estimate",
      "signature": "gds.cliqueCounting.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.closeness.harmonic.mutate",
      "signature": "gds.closeness.harmonic.mutate(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, centralityDistribution :: MAP, configuration :: MAP)",
      "description": "Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
    },
    {
      "name": "gds.closeness.harmonic.mutate.estimate",
      "signature": "gds.closeness.harmonic.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.closeness.harmonic.stats",
      "signature": "gds.closeness.harmonic.stats(graphName :: STRING, configuration = {} :: MAP) :: (centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
    },
    {
      "name": "gds.closeness.harmonic.stats.estimate",
      "signature": "gds.closeness.harmonic.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.closeness.harmonic.stream",
      "signature": "gds.closeness.harmonic.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, score :: FLOAT)",
      "description": "Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
    },
    {
      "name": "gds.closeness.harmonic.stream.estimate",
      "signature": "gds.closeness.harmonic.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.closeness.harmonic.write",
      "signature": "gds.closeness.harmonic.write(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, centralityDistribution :: MAP, configuration :: MAP)",
      "description": "Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
    },
    {
      "name": "gds.closeness.harmonic.write.estimate",
      "signature": "gds.closeness.harmonic.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.closeness.mutate",
      "signature": "gds.closeness.mutate(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, centralityDistribution :: MAP, configuration :: MAP)",
      "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
    },
    {
      "name": "gds.closeness.mutate.estimate",
      "signature": "gds.closeness.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.closeness.stats",
      "signature": "gds.closeness.stats(graphName :: STRING, configuration = {} :: MAP) :: (centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
    },
    {
      "name": "gds.closeness.stats.estimate",
      "signature": "gds.closeness.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.closeness.stream",
      "signature": "gds.closeness.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, score :: FLOAT)",
      "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
    },
    {
      "name": "gds.closeness.stream.estimate",
      "signature": "gds.closeness.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.closeness.write",
      "signature": "gds.closeness.write(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, centralityDistribution :: MAP, configuration :: MAP)",
      "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph."
    },
    {
      "name": "gds.closeness.write.estimate",
      "signature": "gds.closeness.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.collapsePath.mutate",
      "signature": "gds.collapsePath.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "Collapse Path algorithm is a traversal algorithm capable of creating relationships between the start and end nodes of a traversal"
    },
    {
      "name": "gds.degree.mutate",
      "signature": "gds.degree.mutate(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, centralityDistribution :: MAP, configuration :: MAP)",
      "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
    },
    {
      "name": "gds.degree.mutate.estimate",
      "signature": "gds.degree.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.degree.stats",
      "signature": "gds.degree.stats(graphName :: STRING, configuration = {} :: MAP) :: (centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
    },
    {
      "name": "gds.degree.stats.estimate",
      "signature": "gds.degree.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.degree.stream",
      "signature": "gds.degree.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, score :: FLOAT)",
      "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
    },
    {
      "name": "gds.degree.stream.estimate",
      "signature": "gds.degree.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.degree.write",
      "signature": "gds.degree.write(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, centralityDistribution :: MAP, configuration :: MAP)",
      "description": "Degree centrality measures the number of incoming and outgoing relationships from a node."
    },
    {
      "name": "gds.degree.write.estimate",
      "signature": "gds.degree.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.eigenvector.mutate",
      "signature": "gds.eigenvector.mutate(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.eigenvector.mutate.estimate",
      "signature": "gds.eigenvector.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.eigenvector.stats",
      "signature": "gds.eigenvector.stats(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.eigenvector.stats.estimate",
      "signature": "gds.eigenvector.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.eigenvector.stream",
      "signature": "gds.eigenvector.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, score :: FLOAT)",
      "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.eigenvector.stream.estimate",
      "signature": "gds.eigenvector.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.eigenvector.write",
      "signature": "gds.eigenvector.write(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.eigenvector.write.estimate",
      "signature": "gds.eigenvector.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.fastRP.mutate",
      "signature": "gds.fastRP.mutate(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, configuration :: MAP)",
      "description": "Random Projection produces node embeddings via the fastrp algorithm"
    },
    {
      "name": "gds.fastRP.mutate.estimate",
      "signature": "gds.fastRP.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.fastRP.stats",
      "signature": "gds.fastRP.stats(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, configuration :: MAP)",
      "description": "Random Projection produces node embeddings via the fastrp algorithm"
    },
    {
      "name": "gds.fastRP.stats.estimate",
      "signature": "gds.fastRP.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.fastRP.stream",
      "signature": "gds.fastRP.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, embedding :: LIST<FLOAT>)",
      "description": "Random Projection produces node embeddings via the fastrp algorithm"
    },
    {
      "name": "gds.fastRP.stream.estimate",
      "signature": "gds.fastRP.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.fastRP.write",
      "signature": "gds.fastRP.write(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, configuration :: MAP)",
      "description": "Random Projection produces node embeddings via the fastrp algorithm"
    },
    {
      "name": "gds.fastRP.write.estimate",
      "signature": "gds.fastRP.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.graph.drop",
      "signature": "gds.graph.drop(graphName :: ANY, failIfMissing = true :: BOOLEAN, dbName =  :: STRING, username =  :: STRING) :: (graphName :: STRING, database :: STRING, databaseLocation :: STRING, memoryUsage :: STRING, sizeInBytes :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, configuration :: MAP, density :: FLOAT, creationTime :: ZONED DATETIME, modificationTime :: ZONED DATETIME, schema :: MAP, schemaWithOrientation :: MAP)",
      "description": "Drops a named graph from the catalog and frees up the resources it occupies."
    },
    {
      "name": "gds.graph.exists",
      "signature": "gds.graph.exists(graphName :: STRING) :: (graphName :: STRING, exists :: BOOLEAN)",
      "description": "Checks if a graph exists in the catalog."
    },
    {
      "name": "gds.graph.filter",
      "signature": "gds.graph.filter(graphName :: STRING, fromGraphName :: STRING, nodeFilter :: STRING, relationshipFilter :: STRING, configuration = {} :: MAP) :: (graphName :: STRING, fromGraphName :: STRING, nodeFilter :: STRING, relationshipFilter :: STRING, nodeCount :: INTEGER, relationshipCount :: INTEGER, projectMillis :: INTEGER)",
      "description": "Applies node and relationship predicates on a graph and stores the result as a new graph in the catalog."
    },
    {
      "name": "gds.graph.generate",
      "signature": "gds.graph.generate(graphName :: STRING, nodeCount :: INTEGER, averageDegree :: INTEGER, configuration = {} :: MAP) :: (name :: STRING, nodes :: INTEGER, relationships :: INTEGER, generateMillis :: INTEGER, relationshipSeed :: INTEGER, averageDegree :: FLOAT, relationshipDistribution :: STRING, relationshipProperty :: MAP)",
      "description": "Computes a random graph, which will be stored in the graph catalog."
    },
    {
      "name": "gds.graph.list",
      "signature": "gds.graph.list(graphName = d9b6394a-9482-4929-adab-f97df578a6c6 :: STRING) :: (degreeDistribution :: MAP, graphName :: STRING, database :: STRING, databaseLocation :: STRING, memoryUsage :: STRING, sizeInBytes :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, configuration :: MAP, density :: FLOAT, creationTime :: ZONED DATETIME, modificationTime :: ZONED DATETIME, schema :: MAP, schemaWithOrientation :: MAP)",
      "description": "Lists information about named graphs stored in the catalog."
    },
    {
      "name": "gds.graph.nodeLabel.mutate",
      "signature": "gds.graph.nodeLabel.mutate(graphName :: STRING, nodeLabel :: STRING, configuration :: MAP) :: (mutateMillis :: INTEGER, graphName :: STRING, nodeLabel :: STRING, nodeLabelsWritten :: INTEGER, nodeCount :: INTEGER, configuration :: MAP)",
      "description": "Mutates the in-memory graph with the given node Label."
    },
    {
      "name": "gds.graph.nodeLabel.write",
      "signature": "gds.graph.nodeLabel.write(graphName :: STRING, nodeLabel :: STRING, configuration :: MAP) :: (writeMillis :: INTEGER, graphName :: STRING, nodeLabel :: STRING, nodeLabelsWritten :: INTEGER, nodeCount :: INTEGER, configuration :: MAP)",
      "description": "Writes the given node Label to an online Neo4j database."
    },
    {
      "name": "gds.graph.nodeProperties.drop",
      "signature": "gds.graph.nodeProperties.drop(graphName :: STRING, nodeProperties :: ANY, configuration = {} :: MAP) :: (graphName :: STRING, nodeProperties :: LIST<STRING>, propertiesRemoved :: INTEGER)",
      "description": "Removes node properties from a projected graph."
    },
    {
      "name": "gds.graph.nodeProperties.stream",
      "signature": "gds.graph.nodeProperties.stream(graphName :: STRING, nodeProperties :: ANY, nodeLabels = [*] :: ANY, configuration = {} :: MAP) :: (nodeId :: INTEGER, nodeProperty :: STRING, propertyValue :: ANY, nodeLabels :: LIST<STRING>)",
      "description": "Streams the given node properties."
    },
    {
      "name": "gds.graph.nodeProperties.write",
      "signature": "gds.graph.nodeProperties.write(graphName :: STRING, nodeProperties :: ANY, nodeLabels = [*] :: ANY, configuration = {} :: MAP) :: (writeMillis :: INTEGER, graphName :: STRING, nodeProperties :: LIST<STRING>, propertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Writes the given node properties to an online Neo4j database."
    },
    {
      "name": "gds.graph.nodeProperty.stream",
      "signature": "gds.graph.nodeProperty.stream(graphName :: STRING, nodeProperties :: STRING, nodeLabels = [*] :: ANY, configuration = {} :: MAP) :: (nodeId :: INTEGER, propertyValue :: ANY, nodeLabels :: LIST<STRING>)",
      "description": "Streams the given node property."
    },
    {
      "name": "gds.graph.relationship.write",
      "signature": "gds.graph.relationship.write(graphName :: STRING, relationshipType :: STRING, relationshipProperty =  :: STRING, configuration = {} :: MAP) :: (writeMillis :: INTEGER, graphName :: STRING, relationshipType :: STRING, relationshipProperty :: STRING, relationshipsWritten :: INTEGER, propertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Writes the given relationship and an optional relationship property to an online Neo4j database."
    },
    {
      "name": "gds.graph.relationshipProperties.stream",
      "signature": "gds.graph.relationshipProperties.stream(graphName :: STRING, relationshipProperties :: LIST<STRING>, relationshipTypes = [*] :: ANY, configuration = {} :: MAP) :: (sourceNodeId :: INTEGER, targetNodeId :: INTEGER, relationshipType :: STRING, relationshipProperty :: STRING, propertyValue :: INTEGER | FLOAT)",
      "description": "Streams the given relationship properties."
    },
    {
      "name": "gds.graph.relationshipProperties.write",
      "signature": "gds.graph.relationshipProperties.write(graphName :: STRING, relationshipType :: STRING, relationshipProperties = [] :: LIST<STRING>, configuration = {} :: MAP) :: (writeMillis :: INTEGER, graphName :: STRING, relationshipType :: STRING, relationshipProperties :: LIST<STRING>, relationshipsWritten :: INTEGER, propertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Writes the given relationship and a list of relationship properties to an online Neo4j database."
    },
    {
      "name": "gds.graph.relationshipProperty.stream",
      "signature": "gds.graph.relationshipProperty.stream(graphName :: STRING, relationshipProperty :: STRING, relationshipTypes = [*] :: ANY, configuration = {} :: MAP) :: (sourceNodeId :: INTEGER, targetNodeId :: INTEGER, relationshipType :: STRING, propertyValue :: INTEGER | FLOAT)",
      "description": "Streams the given relationship property."
    },
    {
      "name": "gds.graph.relationships.drop",
      "signature": "gds.graph.relationships.drop(graphName :: STRING, relationshipType :: STRING) :: (graphName :: STRING, relationshipType :: STRING, deletedRelationships :: INTEGER, deletedProperties :: MAP)",
      "description": "Delete the relationship type for a given graph stored in the graph-catalog."
    },
    {
      "name": "gds.graph.relationships.stream",
      "signature": "gds.graph.relationships.stream(graphName :: STRING, relationshipTypes = [*] :: ANY, configuration = {} :: MAP) :: (sourceNodeId :: INTEGER, targetNodeId :: INTEGER, relationshipType :: STRING)",
      "description": "Streams the given relationship source/target pairs"
    },
    {
      "name": "gds.graph.relationships.toUndirected",
      "signature": "gds.graph.relationships.toUndirected(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, inputRelationships :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The ToUndirected procedure converts directed relationships to undirected relationships"
    },
    {
      "name": "gds.graph.relationships.toUndirected.estimate",
      "signature": "gds.graph.relationships.toUndirected.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.graph.sample.cnarw",
      "signature": "gds.graph.sample.cnarw(graphName :: STRING, fromGraphName :: STRING, configuration = {} :: MAP) :: (graphName :: STRING, fromGraphName :: STRING, nodeCount :: INTEGER, relationshipCount :: INTEGER, startNodeCount :: INTEGER, projectMillis :: INTEGER)",
      "description": "Constructs a random subgraph based on common neighbour aware random walks"
    },
    {
      "name": "gds.graph.sample.cnarw.estimate",
      "signature": "gds.graph.sample.cnarw.estimate(fromGraphName :: STRING, configuration = {} :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Estimate memory requirements for sampling graph using CNARW algorithm"
    },
    {
      "name": "gds.graph.sample.rwr",
      "signature": "gds.graph.sample.rwr(graphName :: STRING, fromGraphName :: STRING, configuration = {} :: MAP) :: (graphName :: STRING, fromGraphName :: STRING, nodeCount :: INTEGER, relationshipCount :: INTEGER, startNodeCount :: INTEGER, projectMillis :: INTEGER)",
      "description": "Constructs a random subgraph based on random walks with restarts"
    },
    {
      "name": "gds.hashgnn.mutate",
      "signature": "gds.hashgnn.mutate(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, configuration :: MAP)",
      "description": "HashGNN creates node embeddings by hashing and message passing."
    },
    {
      "name": "gds.hashgnn.mutate.estimate",
      "signature": "gds.hashgnn.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.hashgnn.stream",
      "signature": "gds.hashgnn.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, embedding :: LIST<FLOAT>)",
      "description": "HashGNN creates node embeddings by hashing and message passing."
    },
    {
      "name": "gds.hashgnn.stream.estimate",
      "signature": "gds.hashgnn.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.hashgnn.write",
      "signature": "gds.hashgnn.write(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, configuration :: MAP)",
      "description": "HashGNN creates node embeddings by hashing and message passing."
    },
    {
      "name": "gds.hashgnn.write.estimate",
      "signature": "gds.hashgnn.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.hdbscan.mutate",
      "signature": "gds.hdbscan.mutate(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, numberOfClusters :: INTEGER, numberOfNoisePoints :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Hierarchical Density-Based Spatial Clustering of Applications with Noise"
    },
    {
      "name": "gds.hdbscan.mutate.estimate",
      "signature": "gds.hdbscan.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.hdbscan.stats",
      "signature": "gds.hdbscan.stats(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, numberOfClusters :: INTEGER, numberOfNoisePoints :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Hierarchical Density-Based Spatial Clustering of Applications with Noise"
    },
    {
      "name": "gds.hdbscan.stats.estimate",
      "signature": "gds.hdbscan.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.hdbscan.stream",
      "signature": "gds.hdbscan.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, label :: INTEGER)",
      "description": "Hierarchical Density-Based Spatial Clustering of Applications with Noise"
    },
    {
      "name": "gds.hdbscan.stream.estimate",
      "signature": "gds.hdbscan.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.hdbscan.write",
      "signature": "gds.hdbscan.write(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, numberOfClusters :: INTEGER, numberOfNoisePoints :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Hierarchical Density-Based Spatial Clustering of Applications with Noise"
    },
    {
      "name": "gds.hdbscan.write.estimate",
      "signature": "gds.hdbscan.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.influenceMaximization.celf.mutate",
      "signature": "gds.influenceMaximization.celf.mutate(graphName :: STRING, configuration = {} :: MAP) :: (mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, computeMillis :: INTEGER, totalSpread :: FLOAT, nodeCount :: INTEGER, configuration :: MAP)",
      "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes that maximize the expected spread of influence in the network."
    },
    {
      "name": "gds.influenceMaximization.celf.mutate.estimate",
      "signature": "gds.influenceMaximization.celf.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.influenceMaximization.celf.stats",
      "signature": "gds.influenceMaximization.celf.stats(graphName :: STRING, configuration = {} :: MAP) :: (computeMillis :: INTEGER, totalSpread :: FLOAT, nodeCount :: INTEGER, configuration :: MAP)",
      "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes that maximize the expected spread of influence in the network."
    },
    {
      "name": "gds.influenceMaximization.celf.stats.estimate",
      "signature": "gds.influenceMaximization.celf.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.influenceMaximization.celf.stream",
      "signature": "gds.influenceMaximization.celf.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, spread :: FLOAT)",
      "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes that maximize the expected spread of influence in the network."
    },
    {
      "name": "gds.influenceMaximization.celf.stream.estimate",
      "signature": "gds.influenceMaximization.celf.stream.estimate(graphName :: ANY, configuration = {} :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.influenceMaximization.celf.write",
      "signature": "gds.influenceMaximization.celf.write(graphName :: STRING, configuration = {} :: MAP) :: (writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, computeMillis :: INTEGER, totalSpread :: FLOAT, nodeCount :: INTEGER, configuration :: MAP)",
      "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes that maximize the expected spread of influence in the network."
    },
    {
      "name": "gds.influenceMaximization.celf.write.estimate",
      "signature": "gds.influenceMaximization.celf.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.k1coloring.mutate",
      "signature": "gds.k1coloring.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, nodeCount :: INTEGER, colorCount :: INTEGER, ranIterations :: INTEGER, didConverge :: BOOLEAN, configuration :: MAP)",
      "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
    },
    {
      "name": "gds.k1coloring.mutate.estimate",
      "signature": "gds.k1coloring.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.k1coloring.stats",
      "signature": "gds.k1coloring.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, nodeCount :: INTEGER, colorCount :: INTEGER, ranIterations :: INTEGER, didConverge :: BOOLEAN, configuration :: MAP)",
      "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
    },
    {
      "name": "gds.k1coloring.stats.estimate",
      "signature": "gds.k1coloring.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.k1coloring.stream",
      "signature": "gds.k1coloring.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, color :: INTEGER)",
      "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
    },
    {
      "name": "gds.k1coloring.stream.estimate",
      "signature": "gds.k1coloring.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.k1coloring.write",
      "signature": "gds.k1coloring.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, nodeCount :: INTEGER, colorCount :: INTEGER, ranIterations :: INTEGER, didConverge :: BOOLEAN, configuration :: MAP)",
      "description": "The K-1 Coloring algorithm assigns a color to every node in the graph."
    },
    {
      "name": "gds.k1coloring.write.estimate",
      "signature": "gds.k1coloring.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.kcore.mutate",
      "signature": "gds.kcore.mutate(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, degeneracy :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, configuration :: MAP)",
      "description": "It computes the k-core values in a network"
    },
    {
      "name": "gds.kcore.mutate.estimate",
      "signature": "gds.kcore.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.kcore.stats",
      "signature": "gds.kcore.stats(graphName :: STRING, configuration = {} :: MAP) :: (degeneracy :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "It computes the k-core values in a network"
    },
    {
      "name": "gds.kcore.stats.estimate",
      "signature": "gds.kcore.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.kcore.stream",
      "signature": "gds.kcore.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, coreValue :: INTEGER)",
      "description": "It computes the k-core values in a network"
    },
    {
      "name": "gds.kcore.stream.estimate",
      "signature": "gds.kcore.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.kcore.write",
      "signature": "gds.kcore.write(graphName :: STRING, configuration = {} :: MAP) :: (nodePropertiesWritten :: INTEGER, degeneracy :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, configuration :: MAP)",
      "description": "It computes the k-core values in a network"
    },
    {
      "name": "gds.kcore.write.estimate",
      "signature": "gds.kcore.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.kmeans.mutate",
      "signature": "gds.kmeans.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, communityDistribution :: MAP, centroids :: LIST<LIST<FLOAT>>, averageDistanceToCentroid :: FLOAT, averageSilhouette :: FLOAT, configuration :: MAP)",
      "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance"
    },
    {
      "name": "gds.kmeans.mutate.estimate",
      "signature": "gds.kmeans.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.kmeans.stats",
      "signature": "gds.kmeans.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, communityDistribution :: MAP, centroids :: LIST<LIST<FLOAT>>, averageDistanceToCentroid :: FLOAT, averageSilhouette :: FLOAT, configuration :: MAP)",
      "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance"
    },
    {
      "name": "gds.kmeans.stats.estimate",
      "signature": "gds.kmeans.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.kmeans.stream",
      "signature": "gds.kmeans.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, communityId :: INTEGER, distanceFromCentroid :: FLOAT, silhouette :: FLOAT)",
      "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance"
    },
    {
      "name": "gds.kmeans.stream.estimate",
      "signature": "gds.kmeans.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.kmeans.write",
      "signature": "gds.kmeans.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, communityDistribution :: MAP, centroids :: LIST<LIST<FLOAT>>, averageDistanceToCentroid :: FLOAT, averageSilhouette :: FLOAT, configuration :: MAP)",
      "description": "The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance"
    },
    {
      "name": "gds.kmeans.write.estimate",
      "signature": "gds.kmeans.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.knn.filtered.mutate",
      "signature": "gds.knn.filtered.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, relationshipsWritten :: INTEGER, similarityDistribution :: MAP, didConverge :: BOOLEAN, ranIterations :: INTEGER, nodePairsConsidered :: INTEGER, configuration :: MAP)",
      "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes. KNN computes distances based on the similarity of node properties. Filtered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
    },
    {
      "name": "gds.knn.filtered.mutate.estimate",
      "signature": "gds.knn.filtered.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.knn.filtered.stats",
      "signature": "gds.knn.filtered.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, similarityPairs :: INTEGER, similarityDistribution :: MAP, didConverge :: BOOLEAN, ranIterations :: INTEGER, nodePairsConsidered :: INTEGER, configuration :: MAP)",
      "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes. KNN computes distances based on the similarity of node properties. Filtered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
    },
    {
      "name": "gds.knn.filtered.stats.estimate",
      "signature": "gds.knn.filtered.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.knn.filtered.stream",
      "signature": "gds.knn.filtered.stream(graphName :: STRING, configuration = {} :: MAP) :: (node1 :: INTEGER, node2 :: INTEGER, similarity :: FLOAT)",
      "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes. KNN computes distances based on the similarity of node properties. Filtered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
    },
    {
      "name": "gds.knn.filtered.stream.estimate",
      "signature": "gds.knn.filtered.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.knn.filtered.write",
      "signature": "gds.knn.filtered.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, relationshipsWritten :: INTEGER, didConverge :: BOOLEAN, ranIterations :: INTEGER, nodePairsConsidered :: INTEGER, similarityDistribution :: MAP, configuration :: MAP)",
      "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes. KNN computes distances based on the similarity of node properties. Filtered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively."
    },
    {
      "name": "gds.knn.filtered.write.estimate",
      "signature": "gds.knn.filtered.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.knn.mutate",
      "signature": "gds.knn.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, relationshipsWritten :: INTEGER, similarityDistribution :: MAP, didConverge :: BOOLEAN, ranIterations :: INTEGER, nodePairsConsidered :: INTEGER, configuration :: MAP)",
      "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties"
    },
    {
      "name": "gds.knn.mutate.estimate",
      "signature": "gds.knn.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.knn.stats",
      "signature": "gds.knn.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, similarityPairs :: INTEGER, similarityDistribution :: MAP, didConverge :: BOOLEAN, ranIterations :: INTEGER, nodePairsConsidered :: INTEGER, configuration :: MAP)",
      "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties"
    },
    {
      "name": "gds.knn.stats.estimate",
      "signature": "gds.knn.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.knn.stream",
      "signature": "gds.knn.stream(graphName :: STRING, configuration = {} :: MAP) :: (node1 :: INTEGER, node2 :: INTEGER, similarity :: FLOAT)",
      "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties"
    },
    {
      "name": "gds.knn.stream.estimate",
      "signature": "gds.knn.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.knn.write",
      "signature": "gds.knn.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, relationshipsWritten :: INTEGER, didConverge :: BOOLEAN, ranIterations :: INTEGER, nodePairsConsidered :: INTEGER, similarityDistribution :: MAP, configuration :: MAP)",
      "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties"
    },
    {
      "name": "gds.knn.write.estimate",
      "signature": "gds.knn.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.labelPropagation.mutate",
      "signature": "gds.labelPropagation.mutate(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, communityCount :: INTEGER, communityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph."
    },
    {
      "name": "gds.labelPropagation.mutate.estimate",
      "signature": "gds.labelPropagation.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.labelPropagation.stats",
      "signature": "gds.labelPropagation.stats(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, communityCount :: INTEGER, communityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph."
    },
    {
      "name": "gds.labelPropagation.stats.estimate",
      "signature": "gds.labelPropagation.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.labelPropagation.stream",
      "signature": "gds.labelPropagation.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, communityId :: INTEGER)",
      "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph."
    },
    {
      "name": "gds.labelPropagation.stream.estimate",
      "signature": "gds.labelPropagation.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.labelPropagation.write",
      "signature": "gds.labelPropagation.write(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, communityCount :: INTEGER, communityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph."
    },
    {
      "name": "gds.labelPropagation.write.estimate",
      "signature": "gds.labelPropagation.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.leiden.mutate",
      "signature": "gds.leiden.mutate(graphName :: STRING, configuration = {} :: MAP) :: (ranLevels :: INTEGER, didConverge :: BOOLEAN, nodeCount :: INTEGER, communityCount :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, communityDistribution :: MAP, modularities :: LIST<FLOAT>, modularity :: FLOAT, configuration :: MAP)",
      "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
    },
    {
      "name": "gds.leiden.mutate.estimate",
      "signature": "gds.leiden.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.leiden.stats",
      "signature": "gds.leiden.stats(graphName :: STRING, configuration = {} :: MAP) :: (ranLevels :: INTEGER, didConverge :: BOOLEAN, nodeCount :: INTEGER, communityCount :: INTEGER, communityDistribution :: MAP, modularity :: FLOAT, modularities :: LIST<FLOAT>, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
    },
    {
      "name": "gds.leiden.stats.estimate",
      "signature": "gds.leiden.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.leiden.stream",
      "signature": "gds.leiden.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, intermediateCommunityIds :: LIST<INTEGER>, communityId :: INTEGER)",
      "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
    },
    {
      "name": "gds.leiden.stream.estimate",
      "signature": "gds.leiden.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.leiden.write",
      "signature": "gds.leiden.write(graphName :: STRING, configuration = {} :: MAP) :: (ranLevels :: INTEGER, didConverge :: BOOLEAN, nodeCount :: INTEGER, communityCount :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, communityDistribution :: MAP, modularities :: LIST<FLOAT>, modularity :: FLOAT, configuration :: MAP)",
      "description": "Leiden is a community detection algorithm, which guarantees that communities are well connected"
    },
    {
      "name": "gds.leiden.write.estimate",
      "signature": "gds.leiden.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.listProgress",
      "signature": "gds.listProgress(jobId =  :: STRING, showCompleted = false :: BOOLEAN) :: (username :: STRING, jobId :: STRING, taskName :: STRING, progress :: STRING, progressBar :: STRING, status :: STRING, timeStarted :: LOCAL TIME, elapsedTime :: STRING)",
      "description": "List progress events for currently running tasks."
    },
    {
      "name": "gds.localClusteringCoefficient.mutate",
      "signature": "gds.localClusteringCoefficient.mutate(graphName :: STRING, configuration = {} :: MAP) :: (averageClusteringCoefficient :: FLOAT, nodeCount :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP, postProcessingMillis :: INTEGER)",
      "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is."
    },
    {
      "name": "gds.localClusteringCoefficient.mutate.estimate",
      "signature": "gds.localClusteringCoefficient.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.localClusteringCoefficient.stats",
      "signature": "gds.localClusteringCoefficient.stats(graphName :: STRING, configuration = {} :: MAP) :: (averageClusteringCoefficient :: FLOAT, nodeCount :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, configuration :: MAP, postProcessingMillis :: INTEGER)",
      "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is."
    },
    {
      "name": "gds.localClusteringCoefficient.stats.estimate",
      "signature": "gds.localClusteringCoefficient.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.localClusteringCoefficient.stream",
      "signature": "gds.localClusteringCoefficient.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, localClusteringCoefficient :: FLOAT)",
      "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is."
    },
    {
      "name": "gds.localClusteringCoefficient.stream.estimate",
      "signature": "gds.localClusteringCoefficient.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.localClusteringCoefficient.write",
      "signature": "gds.localClusteringCoefficient.write(graphName :: STRING, configuration = {} :: MAP) :: (averageClusteringCoefficient :: FLOAT, nodeCount :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP, postProcessingMillis :: INTEGER)",
      "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is."
    },
    {
      "name": "gds.localClusteringCoefficient.write.estimate",
      "signature": "gds.localClusteringCoefficient.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.louvain.mutate",
      "signature": "gds.louvain.mutate(graphName :: STRING, configuration = {} :: MAP) :: (modularity :: FLOAT, modularities :: LIST<FLOAT>, ranLevels :: INTEGER, communityCount :: INTEGER, communityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The Louvain method for community detection is an algorithm for detecting communities in networks."
    },
    {
      "name": "gds.louvain.mutate.estimate",
      "signature": "gds.louvain.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.louvain.stats",
      "signature": "gds.louvain.stats(graphName :: STRING, configuration = {} :: MAP) :: (modularity :: FLOAT, modularities :: LIST<FLOAT>, ranLevels :: INTEGER, communityCount :: INTEGER, communityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "The Louvain method for community detection is an algorithm for detecting communities in networks."
    },
    {
      "name": "gds.louvain.stats.estimate",
      "signature": "gds.louvain.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.louvain.stream",
      "signature": "gds.louvain.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, intermediateCommunityIds :: LIST<INTEGER>, communityId :: INTEGER)",
      "description": "The Louvain method for community detection is an algorithm for detecting communities in networks."
    },
    {
      "name": "gds.louvain.stream.estimate",
      "signature": "gds.louvain.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.louvain.write",
      "signature": "gds.louvain.write(graphName :: STRING, configuration = {} :: MAP) :: (modularity :: FLOAT, modularities :: LIST<FLOAT>, ranLevels :: INTEGER, communityCount :: INTEGER, communityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The Louvain method for community detection is an algorithm for detecting communities in networks."
    },
    {
      "name": "gds.louvain.write.estimate",
      "signature": "gds.louvain.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.maxkcut.mutate",
      "signature": "gds.maxkcut.mutate(graphName :: STRING, configuration = {} :: MAP) :: (cutCost :: FLOAT, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities."
    },
    {
      "name": "gds.maxkcut.mutate.estimate",
      "signature": "gds.maxkcut.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.maxkcut.stream",
      "signature": "gds.maxkcut.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, communityId :: INTEGER)",
      "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities."
    },
    {
      "name": "gds.maxkcut.stream.estimate",
      "signature": "gds.maxkcut.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.modularityOptimization.mutate",
      "signature": "gds.modularityOptimization.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodes :: INTEGER, didConverge :: BOOLEAN, ranIterations :: INTEGER, modularity :: FLOAT, communityCount :: INTEGER, communityDistribution :: MAP, configuration :: MAP)",
      "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
    },
    {
      "name": "gds.modularityOptimization.mutate.estimate",
      "signature": "gds.modularityOptimization.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.modularityOptimization.stats",
      "signature": "gds.modularityOptimization.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodes :: INTEGER, didConverge :: BOOLEAN, ranIterations :: INTEGER, modularity :: FLOAT, communityCount :: INTEGER, communityDistribution :: MAP, configuration :: MAP)",
      "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
    },
    {
      "name": "gds.modularityOptimization.stats.estimate",
      "signature": "gds.modularityOptimization.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.modularityOptimization.stream",
      "signature": "gds.modularityOptimization.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, communityId :: INTEGER)",
      "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
    },
    {
      "name": "gds.modularityOptimization.stream.estimate",
      "signature": "gds.modularityOptimization.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.modularityOptimization.write",
      "signature": "gds.modularityOptimization.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodes :: INTEGER, didConverge :: BOOLEAN, ranIterations :: INTEGER, modularity :: FLOAT, communityCount :: INTEGER, communityDistribution :: MAP, configuration :: MAP)",
      "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity."
    },
    {
      "name": "gds.modularityOptimization.write.estimate",
      "signature": "gds.modularityOptimization.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.node2vec.mutate",
      "signature": "gds.node2vec.mutate(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP, lossPerIteration :: LIST<FLOAT>)",
      "description": "The Node2Vec algorithm computes embeddings for nodes based on random walks."
    },
    {
      "name": "gds.node2vec.mutate.estimate",
      "signature": "gds.node2vec.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.node2vec.stream",
      "signature": "gds.node2vec.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, embedding :: LIST<FLOAT>)",
      "description": "The Node2Vec algorithm computes embeddings for nodes based on random walks."
    },
    {
      "name": "gds.node2vec.stream.estimate",
      "signature": "gds.node2vec.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.node2vec.write",
      "signature": "gds.node2vec.write(graphName :: STRING, configuration = {} :: MAP) :: (nodeCount :: INTEGER, nodePropertiesWritten :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, configuration :: MAP, lossPerIteration :: LIST<FLOAT>)",
      "description": "The Node2Vec algorithm computes embeddings for nodes based on random walks."
    },
    {
      "name": "gds.node2vec.write.estimate",
      "signature": "gds.node2vec.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.nodeSimilarity.filtered.mutate",
      "signature": "gds.nodeSimilarity.filtered.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, relationshipsWritten :: INTEGER, similarityDistribution :: MAP, configuration :: MAP)",
      "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. The algorithm computes pair-wise similarities based on Jaccard or Overlap metrics. The filtered variant supports limiting which nodes to compare via source and target node filters."
    },
    {
      "name": "gds.nodeSimilarity.filtered.mutate.estimate",
      "signature": "gds.nodeSimilarity.filtered.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.nodeSimilarity.filtered.stats",
      "signature": "gds.nodeSimilarity.filtered.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, similarityPairs :: INTEGER, similarityDistribution :: MAP, configuration :: MAP)",
      "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. The algorithm computes pair-wise similarities based on Jaccard or Overlap metrics. The filtered variant supports limiting which nodes to compare via source and target node filters."
    },
    {
      "name": "gds.nodeSimilarity.filtered.stats.estimate",
      "signature": "gds.nodeSimilarity.filtered.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.nodeSimilarity.filtered.stream",
      "signature": "gds.nodeSimilarity.filtered.stream(graphName :: STRING, configuration = {} :: MAP) :: (node1 :: INTEGER, node2 :: INTEGER, similarity :: FLOAT)",
      "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. The algorithm computes pair-wise similarities based on Jaccard or Overlap metrics. The filtered variant supports limiting which nodes to compare via source and target node filters."
    },
    {
      "name": "gds.nodeSimilarity.filtered.stream.estimate",
      "signature": "gds.nodeSimilarity.filtered.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.nodeSimilarity.filtered.write",
      "signature": "gds.nodeSimilarity.filtered.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, relationshipsWritten :: INTEGER, similarityDistribution :: MAP, configuration :: MAP)",
      "description": "The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. The algorithm computes pair-wise similarities based on Jaccard or Overlap metrics. The filtered variant supports limiting which nodes to compare via source and target node filters."
    },
    {
      "name": "gds.nodeSimilarity.filtered.write.estimate",
      "signature": "gds.nodeSimilarity.filtered.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.nodeSimilarity.mutate",
      "signature": "gds.nodeSimilarity.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, relationshipsWritten :: INTEGER, similarityDistribution :: MAP, configuration :: MAP)",
      "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric."
    },
    {
      "name": "gds.nodeSimilarity.mutate.estimate",
      "signature": "gds.nodeSimilarity.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.nodeSimilarity.stats",
      "signature": "gds.nodeSimilarity.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, similarityPairs :: INTEGER, similarityDistribution :: MAP, configuration :: MAP)",
      "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric."
    },
    {
      "name": "gds.nodeSimilarity.stats.estimate",
      "signature": "gds.nodeSimilarity.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.nodeSimilarity.stream",
      "signature": "gds.nodeSimilarity.stream(graphName :: STRING, configuration = {} :: MAP) :: (node1 :: INTEGER, node2 :: INTEGER, similarity :: FLOAT)",
      "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric."
    },
    {
      "name": "gds.nodeSimilarity.stream.estimate",
      "signature": "gds.nodeSimilarity.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.nodeSimilarity.write",
      "signature": "gds.nodeSimilarity.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodesCompared :: INTEGER, relationshipsWritten :: INTEGER, similarityDistribution :: MAP, configuration :: MAP)",
      "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric."
    },
    {
      "name": "gds.nodeSimilarity.write.estimate",
      "signature": "gds.nodeSimilarity.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.pageRank.mutate",
      "signature": "gds.pageRank.mutate(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.pageRank.mutate.estimate",
      "signature": "gds.pageRank.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.pageRank.stats",
      "signature": "gds.pageRank.stats(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.pageRank.stats.estimate",
      "signature": "gds.pageRank.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.pageRank.stream",
      "signature": "gds.pageRank.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, score :: FLOAT)",
      "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.pageRank.stream.estimate",
      "signature": "gds.pageRank.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.pageRank.write",
      "signature": "gds.pageRank.write(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, centralityDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes."
    },
    {
      "name": "gds.pageRank.write.estimate",
      "signature": "gds.pageRank.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.prizeSteinerTree.mutate",
      "signature": "gds.prizeSteinerTree.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, effectiveNodeCount :: INTEGER, totalWeight :: FLOAT, sumOfPrizes :: FLOAT, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The prize collecting steiner tree algorithm accepts a weighted undirected graph where each node has a prize property. It then attempts to find a spanning tree that maximizes the sum of prizes of the nodes in the treewhile minimizing the sum of weights for the tree's relationships as well as the sum of prizes for nodes outside the tree."
    },
    {
      "name": "gds.prizeSteinerTree.mutate.estimate",
      "signature": "gds.prizeSteinerTree.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.prizeSteinerTree.stats",
      "signature": "gds.prizeSteinerTree.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, effectiveNodeCount :: INTEGER, totalWeight :: FLOAT, sumOfPrizes :: FLOAT, configuration :: MAP)",
      "description": "The prize collecting steiner tree algorithm accepts a weighted undirected graph where each node has a prize property. It then attempts to find a spanning tree that maximizes the sum of prizes of the nodes in the treewhile minimizing the sum of weights for the tree's relationships as well as the sum of prizes for nodes outside the tree."
    },
    {
      "name": "gds.prizeSteinerTree.stats.estimate",
      "signature": "gds.prizeSteinerTree.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.prizeSteinerTree.stream",
      "signature": "gds.prizeSteinerTree.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, parentId :: INTEGER, weight :: FLOAT)",
      "description": "The prize collecting steiner tree algorithm accepts a weighted undirected graph where each node has a prize property. It then attempts to find a spanning tree that maximizes the sum of prizes of the nodes in the treewhile minimizing the sum of weights for the tree's relationships as well as the sum of prizes for nodes outside the tree."
    },
    {
      "name": "gds.prizeSteinerTree.stream.estimate",
      "signature": "gds.prizeSteinerTree.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.prizeSteinerTree.write",
      "signature": "gds.prizeSteinerTree.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, effectiveNodeCount :: INTEGER, totalWeight :: FLOAT, sumOfPrizes :: FLOAT, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The prize collecting steiner tree algorithm accepts a weighted undirected graph where each node has a prize property. It then attempts to find a spanning tree that maximizes the sum of prizes of the nodes in the treewhile minimizing the sum of weights for the tree's relationships as well as the sum of prizes for nodes outside the tree."
    },
    {
      "name": "gds.prizeSteinerTree.write.estimate",
      "signature": "gds.prizeSteinerTree.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.scaleProperties.mutate",
      "signature": "gds.scaleProperties.mutate(graphName :: STRING, configuration = {} :: MAP) :: (scalerStatistics :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Scale node properties"
    },
    {
      "name": "gds.scaleProperties.mutate.estimate",
      "signature": "gds.scaleProperties.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.scaleProperties.stats",
      "signature": "gds.scaleProperties.stats(graphName :: STRING, configuration = {} :: MAP) :: (scalerStatistics :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "Scale node properties"
    },
    {
      "name": "gds.scaleProperties.stats.estimate",
      "signature": "gds.scaleProperties.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.scaleProperties.stream",
      "signature": "gds.scaleProperties.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, scaledProperty :: LIST<FLOAT>)",
      "description": "Scale node properties"
    },
    {
      "name": "gds.scaleProperties.stream.estimate",
      "signature": "gds.scaleProperties.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.scaleProperties.write",
      "signature": "gds.scaleProperties.write(graphName :: STRING, configuration = {} :: MAP) :: (scalerStatistics :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, postProcessingMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "Scale node properties"
    },
    {
      "name": "gds.scaleProperties.write.estimate",
      "signature": "gds.scaleProperties.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.scc.mutate",
      "signature": "gds.scc.mutate(graphName :: STRING, configuration = {} :: MAP) :: (componentCount :: INTEGER, componentDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component."
    },
    {
      "name": "gds.scc.mutate.estimate",
      "signature": "gds.scc.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.scc.stats",
      "signature": "gds.scc.stats(graphName :: STRING, configuration = {} :: MAP) :: (componentCount :: INTEGER, componentDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component."
    },
    {
      "name": "gds.scc.stats.estimate",
      "signature": "gds.scc.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.scc.stream",
      "signature": "gds.scc.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, componentId :: INTEGER)",
      "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component."
    },
    {
      "name": "gds.scc.stream.estimate",
      "signature": "gds.scc.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.scc.write",
      "signature": "gds.scc.write(graphName :: STRING, configuration = {} :: MAP) :: (componentCount :: INTEGER, componentDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component."
    },
    {
      "name": "gds.scc.write.estimate",
      "signature": "gds.scc.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.session.delete",
      "signature": "gds.session.delete(name :: STRING, projectId =  :: STRING) :: (deleted :: BOOLEAN)",
      "description": ""
    },
    {
      "name": "gds.session.getOrCreate",
      "signature": "gds.session.getOrCreate(sessionName :: STRING, memory :: STRING, ttl = null :: ANY, cloudLocation = null :: MAP) :: (id :: STRING, name :: STRING, auraInstanceId :: STRING, databaseId :: STRING, memory :: STRING, status :: STRING, creationTime :: ZONED DATETIME, host :: STRING, expiryDate :: ZONED DATETIME, ttl :: DURATION, cloudLocation :: MAP, errorMessage :: STRING)",
      "description": ""
    },
    {
      "name": "gds.session.list",
      "signature": "gds.session.list(projectId =  :: STRING, filterAuraInstance = false :: BOOLEAN) :: (id :: STRING, name :: STRING, auraInstanceId :: STRING, databaseId :: STRING, memory :: STRING, status :: STRING, creationTime :: ZONED DATETIME, host :: STRING, expiryDate :: ZONED DATETIME, ttl :: DURATION, cloudLocation :: MAP, errorMessage :: STRING)",
      "description": ""
    },
    {
      "name": "gds.shortestPath.astar.mutate",
      "signature": "gds.shortestPath.astar.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster."
    },
    {
      "name": "gds.shortestPath.astar.mutate.estimate",
      "signature": "gds.shortestPath.astar.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.shortestPath.astar.stream",
      "signature": "gds.shortestPath.astar.stream(graphName :: STRING, configuration = {} :: MAP) :: (index :: INTEGER, sourceNode :: INTEGER, targetNode :: INTEGER, totalCost :: FLOAT, nodeIds :: LIST<INTEGER>, costs :: LIST<FLOAT>, path :: PATH)",
      "description": "The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster."
    },
    {
      "name": "gds.shortestPath.astar.stream.estimate",
      "signature": "gds.shortestPath.astar.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.shortestPath.astar.write",
      "signature": "gds.shortestPath.astar.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster."
    },
    {
      "name": "gds.shortestPath.astar.write.estimate",
      "signature": "gds.shortestPath.astar.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.shortestPath.dijkstra.mutate",
      "signature": "gds.shortestPath.dijkstra.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes."
    },
    {
      "name": "gds.shortestPath.dijkstra.mutate.estimate",
      "signature": "gds.shortestPath.dijkstra.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.shortestPath.dijkstra.stream",
      "signature": "gds.shortestPath.dijkstra.stream(graphName :: STRING, configuration = {} :: MAP) :: (index :: INTEGER, sourceNode :: INTEGER, targetNode :: INTEGER, totalCost :: FLOAT, nodeIds :: LIST<INTEGER>, costs :: LIST<FLOAT>, path :: PATH)",
      "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes."
    },
    {
      "name": "gds.shortestPath.dijkstra.stream.estimate",
      "signature": "gds.shortestPath.dijkstra.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.shortestPath.dijkstra.write",
      "signature": "gds.shortestPath.dijkstra.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes."
    },
    {
      "name": "gds.shortestPath.dijkstra.write.estimate",
      "signature": "gds.shortestPath.dijkstra.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.shortestPath.yens.mutate",
      "signature": "gds.shortestPath.yens.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, postProcessingMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes."
    },
    {
      "name": "gds.shortestPath.yens.mutate.estimate",
      "signature": "gds.shortestPath.yens.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.shortestPath.yens.stream",
      "signature": "gds.shortestPath.yens.stream(graphName :: STRING, configuration = {} :: MAP) :: (index :: INTEGER, sourceNode :: INTEGER, targetNode :: INTEGER, totalCost :: FLOAT, nodeIds :: LIST<INTEGER>, costs :: LIST<FLOAT>, path :: PATH)",
      "description": "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes."
    },
    {
      "name": "gds.shortestPath.yens.stream.estimate",
      "signature": "gds.shortestPath.yens.stream.estimate(graphName :: ANY, configuration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.shortestPath.yens.write",
      "signature": "gds.shortestPath.yens.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes."
    },
    {
      "name": "gds.shortestPath.yens.write.estimate",
      "signature": "gds.shortestPath.yens.write.estimate(graphName :: ANY, configuration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.sllpa.mutate",
      "signature": "gds.sllpa.mutate(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph."
    },
    {
      "name": "gds.sllpa.mutate.estimate",
      "signature": "gds.sllpa.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.sllpa.stats",
      "signature": "gds.sllpa.stats(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, configuration :: MAP)",
      "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph."
    },
    {
      "name": "gds.sllpa.stats.estimate",
      "signature": "gds.sllpa.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.sllpa.stream",
      "signature": "gds.sllpa.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, values :: MAP)",
      "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph."
    },
    {
      "name": "gds.sllpa.stream.estimate",
      "signature": "gds.sllpa.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.sllpa.write",
      "signature": "gds.sllpa.write(graphName :: STRING, configuration = {} :: MAP) :: (ranIterations :: INTEGER, didConverge :: BOOLEAN, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph."
    },
    {
      "name": "gds.sllpa.write.estimate",
      "signature": "gds.sllpa.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.spanningTree.mutate",
      "signature": "gds.spanningTree.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, effectiveNodeCount :: INTEGER, relationshipsWritten :: INTEGER, totalWeight :: FLOAT, configuration :: MAP)",
      "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized."
    },
    {
      "name": "gds.spanningTree.mutate.estimate",
      "signature": "gds.spanningTree.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.spanningTree.stats",
      "signature": "gds.spanningTree.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, effectiveNodeCount :: INTEGER, totalWeight :: FLOAT, configuration :: MAP)",
      "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized."
    },
    {
      "name": "gds.spanningTree.stats.estimate",
      "signature": "gds.spanningTree.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.spanningTree.stream",
      "signature": "gds.spanningTree.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, parentId :: INTEGER, weight :: FLOAT)",
      "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized."
    },
    {
      "name": "gds.spanningTree.stream.estimate",
      "signature": "gds.spanningTree.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.spanningTree.write",
      "signature": "gds.spanningTree.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, effectiveNodeCount :: INTEGER, relationshipsWritten :: INTEGER, totalWeight :: FLOAT, configuration :: MAP)",
      "description": "The spanning tree algorithm visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized."
    },
    {
      "name": "gds.spanningTree.write.estimate",
      "signature": "gds.spanningTree.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.steinerTree.mutate",
      "signature": "gds.steinerTree.mutate(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, effectiveNodeCount :: INTEGER, effectiveTargetNodesCount :: INTEGER, totalWeight :: FLOAT, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes. It then attempts to find a spanning tree where there is a path from the source node to each target node, such that the total weight of the relationships is as low as possible."
    },
    {
      "name": "gds.steinerTree.mutate.estimate",
      "signature": "gds.steinerTree.mutate.estimate(graphName :: ANY, configuration = {} :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.steinerTree.stats",
      "signature": "gds.steinerTree.stats(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, effectiveNodeCount :: INTEGER, effectiveTargetNodesCount :: INTEGER, totalWeight :: FLOAT, configuration :: MAP)",
      "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes. It then attempts to find a spanning tree where there is a path from the source node to each target node, such that the total weight of the relationships is as low as possible."
    },
    {
      "name": "gds.steinerTree.stats.estimate",
      "signature": "gds.steinerTree.stats.estimate(graphName :: ANY, configuration = {} :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.steinerTree.stream",
      "signature": "gds.steinerTree.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, parentId :: INTEGER, weight :: FLOAT)",
      "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes. It then attempts to find a spanning tree where there is a path from the source node to each target node, such that the total weight of the relationships is as low as possible."
    },
    {
      "name": "gds.steinerTree.stream.estimate",
      "signature": "gds.steinerTree.stream.estimate(graphName :: ANY, configuration = {} :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.steinerTree.write",
      "signature": "gds.steinerTree.write(graphName :: STRING, configuration = {} :: MAP) :: (preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, effectiveNodeCount :: INTEGER, effectiveTargetNodesCount :: INTEGER, totalWeight :: FLOAT, relationshipsWritten :: INTEGER, configuration :: MAP)",
      "description": "The steiner tree algorithm accepts a source node, as well as a list of target nodes. It then attempts to find a spanning tree where there is a path from the source node to each target node, such that the total weight of the relationships is as low as possible."
    },
    {
      "name": "gds.steinerTree.write.estimate",
      "signature": "gds.steinerTree.write.estimate(graphName :: ANY, configuration = {} :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.triangleCount.mutate",
      "signature": "gds.triangleCount.mutate(graphName :: STRING, configuration = {} :: MAP) :: (globalTriangleCount :: INTEGER, nodeCount :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP, postProcessingMillis :: INTEGER)",
      "description": "Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph."
    },
    {
      "name": "gds.triangleCount.mutate.estimate",
      "signature": "gds.triangleCount.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.triangleCount.stats",
      "signature": "gds.triangleCount.stats(graphName :: STRING, configuration = {} :: MAP) :: (globalTriangleCount :: INTEGER, nodeCount :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, configuration :: MAP, postProcessingMillis :: INTEGER)",
      "description": "Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph."
    },
    {
      "name": "gds.triangleCount.stats.estimate",
      "signature": "gds.triangleCount.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.triangleCount.stream",
      "signature": "gds.triangleCount.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, triangleCount :: INTEGER)",
      "description": "Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph."
    },
    {
      "name": "gds.triangleCount.stream.estimate",
      "signature": "gds.triangleCount.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.triangleCount.write",
      "signature": "gds.triangleCount.write(graphName :: STRING, configuration = {} :: MAP) :: (globalTriangleCount :: INTEGER, nodeCount :: INTEGER, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP, postProcessingMillis :: INTEGER)",
      "description": "Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph."
    },
    {
      "name": "gds.triangleCount.write.estimate",
      "signature": "gds.triangleCount.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.wcc.mutate",
      "signature": "gds.wcc.mutate(graphName :: STRING, configuration = {} :: MAP) :: (componentCount :: INTEGER, componentDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, mutateMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component."
    },
    {
      "name": "gds.wcc.mutate.estimate",
      "signature": "gds.wcc.mutate.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.wcc.stats",
      "signature": "gds.wcc.stats(graphName :: STRING, configuration = {} :: MAP) :: (componentCount :: INTEGER, componentDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, configuration :: MAP)",
      "description": "The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component."
    },
    {
      "name": "gds.wcc.stats.estimate",
      "signature": "gds.wcc.stats.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.wcc.stream",
      "signature": "gds.wcc.stream(graphName :: STRING, configuration = {} :: MAP) :: (nodeId :: INTEGER, componentId :: INTEGER)",
      "description": "The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component."
    },
    {
      "name": "gds.wcc.stream.estimate",
      "signature": "gds.wcc.stream.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "gds.wcc.write",
      "signature": "gds.wcc.write(graphName :: STRING, configuration = {} :: MAP) :: (componentCount :: INTEGER, componentDistribution :: MAP, preProcessingMillis :: INTEGER, computeMillis :: INTEGER, postProcessingMillis :: INTEGER, writeMillis :: INTEGER, nodePropertiesWritten :: INTEGER, configuration :: MAP)",
      "description": "The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component."
    },
    {
      "name": "gds.wcc.write.estimate",
      "signature": "gds.wcc.write.estimate(graphNameOrConfiguration :: ANY, algoConfiguration :: MAP) :: (requiredMemory :: STRING, treeView :: STRING, mapView :: MAP, bytesMin :: INTEGER, bytesMax :: INTEGER, nodeCount :: INTEGER, relationshipCount :: INTEGER, heapPercentageMin :: FLOAT, heapPercentageMax :: FLOAT)",
      "description": "Returns an estimation of the memory consumption for that procedure."
    },
    {
      "name": "genai.vector.encodeBatch",
      "signature": "genai.vector.encodeBatch(resources :: LIST<STRING>, provider :: STRING, configuration = {} :: ANY) :: (index :: INTEGER, resource :: STRING, vector :: ANY)",
      "description": "Encode a given batch of resources as vectors using the named provider.\nFor each element in the given resource LIST this returns:\n    * the corresponding 'index' within that LIST,\n    * the original 'resource' element itself,\n    * and the encoded 'vector'.\n"
    },
    {
      "name": "tx.getMetaData",
      "signature": "tx.getMetaData() :: (metadata :: MAP)",
      "description": "Provides attached transaction metadata."
    },
    {
      "name": "tx.setMetaData",
      "signature": "tx.setMetaData(data :: MAP)",
      "description": "Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log."
    }
  ],
  "embedding": {
    "found": true,
    "sample_count": 20,
    "sample_dimension": 1536,
    "sample_preview": [
      -0.022096512839198112,
      0.022189132869243622,
      0.06356386095285416,
      0.002689291024580598,
      0.020879218354821205,
      0.02990306355059147,
      0.002429623855277896,
      0.049300361424684525,
      0.027812495827674866,
      0.018920965492725372
    ]
  },
  "recommendation": "gds",
  "notes": [],
  "interesting_procedures": [
    "apoc.algo.aStar",
    "apoc.algo.aStarConfig",
    "apoc.algo.allSimplePaths",
    "apoc.algo.cover",
    "apoc.algo.dijkstra",
    "apoc.atomic.add",
    "apoc.atomic.concat",
    "apoc.atomic.insert",
    "apoc.atomic.remove",
    "apoc.atomic.subtract",
    "apoc.atomic.update",
    "apoc.case",
    "apoc.coll.elements",
    "apoc.coll.partition",
    "apoc.coll.split",
    "apoc.coll.zipToRows",
    "apoc.convert.setJsonProperty",
    "apoc.convert.toTree",
    "apoc.create.addLabels",
    "apoc.create.clonePathToVirtual",
    "apoc.create.clonePathsToVirtual",
    "apoc.create.node",
    "apoc.create.nodes",
    "apoc.create.relationship",
    "apoc.create.removeLabels",
    "apoc.create.removeProperties",
    "apoc.create.removeRelProperties",
    "apoc.create.setLabels",
    "apoc.create.setProperties",
    "apoc.create.setProperty",
    "apoc.create.setRelProperties",
    "apoc.create.setRelProperty",
    "apoc.create.uuids",
    "apoc.create.vNode",
    "apoc.create.vNodes",
    "apoc.create.vRelationship",
    "apoc.create.virtualPath",
    "apoc.cypher.doIt",
    "apoc.cypher.run",
    "apoc.cypher.runMany",
    "apoc.cypher.runTimeboxed",
    "apoc.do.case",
    "apoc.do.when",
    "apoc.example.movies",
    "apoc.export.csv.all",
    "apoc.export.csv.data",
    "apoc.export.csv.graph",
    "apoc.export.csv.query",
    "apoc.export.cypher.all",
    "apoc.export.cypher.data",
    "apoc.export.cypher.graph",
    "apoc.export.cypher.query",
    "apoc.export.cypher.schema",
    "apoc.export.graphml.all",
    "apoc.export.graphml.data",
    "apoc.export.graphml.graph",
    "apoc.export.graphml.query",
    "apoc.export.json.all",
    "apoc.export.json.data",
    "apoc.export.json.graph",
    "apoc.export.json.query",
    "apoc.graph.from",
    "apoc.graph.fromCypher",
    "apoc.graph.fromDB",
    "apoc.graph.fromData",
    "apoc.graph.fromDocument",
    "apoc.graph.fromPath",
    "apoc.graph.fromPaths",
    "apoc.graph.validateDocument",
    "apoc.help",
    "apoc.import.csv",
    "apoc.import.graphml",
    "apoc.load.json",
    "apoc.load.jsonArray",
    "apoc.load.xml",
    "apoc.lock.all",
    "apoc.lock.nodes",
    "apoc.lock.read.nodes",
    "apoc.lock.read.rels",
    "apoc.lock.rels",
    "apoc.math.regr",
    "apoc.merge.node",
    "apoc.merge.node.eager",
    "apoc.merge.nodeWithStats",
    "apoc.merge.nodeWithStats.eager",
    "apoc.merge.relationship",
    "apoc.merge.relationship.eager",
    "apoc.merge.relationshipWithStats",
    "apoc.merge.relationshipWithStats.eager",
    "apoc.meta.data",
    "apoc.meta.data.of",
    "apoc.meta.graph",
    "apoc.meta.graph.of",
    "apoc.meta.graphSample",
    "apoc.meta.nodeTypeProperties",
    "apoc.meta.relTypeProperties",
    "apoc.meta.schema",
    "apoc.meta.stats",
    "apoc.meta.subGraph",
    "apoc.neighbors.athop",
    "apoc.neighbors.athop.count",
    "apoc.neighbors.byhop",
    "apoc.neighbors.byhop.count",
    "apoc.neighbors.tohop",
    "apoc.neighbors.tohop.count",
    "apoc.nodes.collapse",
    "apoc.nodes.cycles",
    "apoc.nodes.delete",
    "apoc.nodes.get",
    "apoc.nodes.group",
    "apoc.nodes.link",
    "apoc.nodes.rels",
    "apoc.path.expand",
    "apoc.path.expandConfig",
    "apoc.path.spanningTree",
    "apoc.path.subgraphAll",
    "apoc.path.subgraphNodes",
    "apoc.paths.toJsonTree",
    "apoc.periodic.cancel",
    "apoc.periodic.commit",
    "apoc.periodic.countdown",
    "apoc.periodic.iterate",
    "apoc.periodic.list",
    "apoc.periodic.repeat",
    "apoc.periodic.submit",
    "apoc.refactor.categorize",
    "apoc.refactor.cloneNodes",
    "apoc.refactor.cloneSubgraph",
    "apoc.refactor.cloneSubgraphFromPaths",
    "apoc.refactor.collapseNode",
    "apoc.refactor.extractNode",
    "apoc.refactor.from",
    "apoc.refactor.invert",
    "apoc.refactor.mergeNodes",
    "apoc.refactor.mergeRelationships",
    "apoc.refactor.normalizeAsBoolean",
    "apoc.refactor.rename.label",
    "apoc.refactor.rename.nodeProperty",
    "apoc.refactor.rename.type",
    "apoc.refactor.rename.typeProperty",
    "apoc.refactor.setType",
    "apoc.refactor.to",
    "apoc.schema.assert",
    "apoc.schema.nodes",
    "apoc.schema.properties.distinct",
    "apoc.schema.properties.distinctCount",
    "apoc.schema.relationships",
    "apoc.search.multiSearchReduced",
    "apoc.search.node",
    "apoc.search.nodeAll",
    "apoc.search.nodeAllReduced",
    "apoc.search.nodeReduced",
    "apoc.spatial.geocode",
    "apoc.spatial.geocodeOnce",
    "apoc.spatial.reverseGeocode",
    "apoc.spatial.sortByDistance",
    "apoc.stats.degrees",
    "apoc.text.phoneticDelta",
    "apoc.util.sleep",
    "apoc.util.validate",
    "apoc.warmup.run",
    "apoc.when",
    "db.create.setNodeVectorProperty",
    "db.create.setRelationshipVectorProperty",
    "db.create.setVectorProperty",
    "db.index.vector.createNodeIndex",
    "db.index.vector.queryNodes",
    "db.index.vector.queryRelationships",
    "gds.allShortestPaths.delta.mutate",
    "gds.allShortestPaths.delta.mutate.estimate",
    "gds.allShortestPaths.delta.stats",
    "gds.allShortestPaths.delta.stats.estimate",
    "gds.allShortestPaths.delta.stream",
    "gds.allShortestPaths.delta.stream.estimate",
    "gds.allShortestPaths.delta.write",
    "gds.allShortestPaths.delta.write.estimate",
    "gds.allShortestPaths.dijkstra.mutate",
    "gds.allShortestPaths.dijkstra.mutate.estimate",
    "gds.allShortestPaths.dijkstra.stream",
    "gds.allShortestPaths.dijkstra.stream.estimate",
    "gds.allShortestPaths.dijkstra.write",
    "gds.allShortestPaths.dijkstra.write.estimate",
    "gds.articleRank.mutate",
    "gds.articleRank.mutate.estimate",
    "gds.articleRank.stats",
    "gds.articleRank.stats.estimate",
    "gds.articleRank.stream",
    "gds.articleRank.stream.estimate",
    "gds.articleRank.write",
    "gds.articleRank.write.estimate",
    "gds.articulationPoints.mutate",
    "gds.articulationPoints.mutate.estimate",
    "gds.articulationPoints.stats",
    "gds.articulationPoints.stats.estimate",
    "gds.articulationPoints.stream",
    "gds.articulationPoints.stream.estimate",
    "gds.articulationPoints.write",
    "gds.articulationPoints.write.estimate",
    "gds.bellmanFord.mutate",
    "gds.bellmanFord.mutate.estimate",
    "gds.bellmanFord.stats",
    "gds.bellmanFord.stats.estimate",
    "gds.bellmanFord.stream",
    "gds.bellmanFord.stream.estimate",
    "gds.bellmanFord.write",
    "gds.bellmanFord.write.estimate",
    "gds.betweenness.mutate",
    "gds.betweenness.mutate.estimate",
    "gds.betweenness.stats",
    "gds.betweenness.stats.estimate",
    "gds.betweenness.stream",
    "gds.betweenness.stream.estimate",
    "gds.betweenness.write",
    "gds.betweenness.write.estimate",
    "gds.cliqueCounting.mutate",
    "gds.cliqueCounting.mutate.estimate",
    "gds.cliqueCounting.stats",
    "gds.cliqueCounting.stats.estimate",
    "gds.cliqueCounting.stream",
    "gds.cliqueCounting.stream.estimate",
    "gds.cliqueCounting.write",
    "gds.cliqueCounting.write.estimate",
    "gds.closeness.harmonic.mutate",
    "gds.closeness.harmonic.mutate.estimate",
    "gds.closeness.harmonic.stats",
    "gds.closeness.harmonic.stats.estimate",
    "gds.closeness.harmonic.stream",
    "gds.closeness.harmonic.stream.estimate",
    "gds.closeness.harmonic.write",
    "gds.closeness.harmonic.write.estimate",
    "gds.closeness.mutate",
    "gds.closeness.mutate.estimate",
    "gds.closeness.stats",
    "gds.closeness.stats.estimate",
    "gds.closeness.stream",
    "gds.closeness.stream.estimate",
    "gds.closeness.write",
    "gds.closeness.write.estimate",
    "gds.collapsePath.mutate",
    "gds.degree.mutate",
    "gds.degree.mutate.estimate",
    "gds.degree.stats",
    "gds.degree.stats.estimate",
    "gds.degree.stream",
    "gds.degree.stream.estimate",
    "gds.degree.write",
    "gds.degree.write.estimate",
    "gds.eigenvector.mutate",
    "gds.eigenvector.mutate.estimate",
    "gds.eigenvector.stats",
    "gds.eigenvector.stats.estimate",
    "gds.eigenvector.stream",
    "gds.eigenvector.stream.estimate",
    "gds.eigenvector.write",
    "gds.eigenvector.write.estimate",
    "gds.fastRP.mutate",
    "gds.fastRP.mutate.estimate",
    "gds.fastRP.stats",
    "gds.fastRP.stats.estimate",
    "gds.fastRP.stream",
    "gds.fastRP.stream.estimate",
    "gds.fastRP.write",
    "gds.fastRP.write.estimate",
    "gds.graph.drop",
    "gds.graph.exists",
    "gds.graph.filter",
    "gds.graph.generate",
    "gds.graph.list",
    "gds.graph.nodeLabel.mutate",
    "gds.graph.nodeLabel.write",
    "gds.graph.nodeProperties.drop",
    "gds.graph.nodeProperties.stream",
    "gds.graph.nodeProperties.write",
    "gds.graph.nodeProperty.stream",
    "gds.graph.relationship.write",
    "gds.graph.relationshipProperties.stream",
    "gds.graph.relationshipProperties.write",
    "gds.graph.relationshipProperty.stream",
    "gds.graph.relationships.drop",
    "gds.graph.relationships.stream",
    "gds.graph.relationships.toUndirected",
    "gds.graph.relationships.toUndirected.estimate",
    "gds.graph.sample.cnarw",
    "gds.graph.sample.cnarw.estimate",
    "gds.graph.sample.rwr",
    "gds.hashgnn.mutate",
    "gds.hashgnn.mutate.estimate",
    "gds.hashgnn.stream",
    "gds.hashgnn.stream.estimate",
    "gds.hashgnn.write",
    "gds.hashgnn.write.estimate",
    "gds.hdbscan.mutate",
    "gds.hdbscan.mutate.estimate",
    "gds.hdbscan.stats",
    "gds.hdbscan.stats.estimate",
    "gds.hdbscan.stream",
    "gds.hdbscan.stream.estimate",
    "gds.hdbscan.write",
    "gds.hdbscan.write.estimate",
    "gds.influenceMaximization.celf.mutate",
    "gds.influenceMaximization.celf.mutate.estimate",
    "gds.influenceMaximization.celf.stats",
    "gds.influenceMaximization.celf.stats.estimate",
    "gds.influenceMaximization.celf.stream",
    "gds.influenceMaximization.celf.stream.estimate",
    "gds.influenceMaximization.celf.write",
    "gds.influenceMaximization.celf.write.estimate",
    "gds.k1coloring.mutate",
    "gds.k1coloring.mutate.estimate",
    "gds.k1coloring.stats",
    "gds.k1coloring.stats.estimate",
    "gds.k1coloring.stream",
    "gds.k1coloring.stream.estimate",
    "gds.k1coloring.write",
    "gds.k1coloring.write.estimate",
    "gds.kcore.mutate",
    "gds.kcore.mutate.estimate",
    "gds.kcore.stats",
    "gds.kcore.stats.estimate",
    "gds.kcore.stream",
    "gds.kcore.stream.estimate",
    "gds.kcore.write",
    "gds.kcore.write.estimate",
    "gds.kmeans.mutate",
    "gds.kmeans.mutate.estimate",
    "gds.kmeans.stats",
    "gds.kmeans.stats.estimate",
    "gds.kmeans.stream",
    "gds.kmeans.stream.estimate",
    "gds.kmeans.write",
    "gds.kmeans.write.estimate",
    "gds.knn.filtered.mutate",
    "gds.knn.filtered.mutate.estimate",
    "gds.knn.filtered.stats",
    "gds.knn.filtered.stats.estimate",
    "gds.knn.filtered.stream",
    "gds.knn.filtered.stream.estimate",
    "gds.knn.filtered.write",
    "gds.knn.filtered.write.estimate",
    "gds.knn.mutate",
    "gds.knn.mutate.estimate",
    "gds.knn.stats",
    "gds.knn.stats.estimate",
    "gds.knn.stream",
    "gds.knn.stream.estimate",
    "gds.knn.write",
    "gds.knn.write.estimate",
    "gds.labelPropagation.mutate",
    "gds.labelPropagation.mutate.estimate",
    "gds.labelPropagation.stats",
    "gds.labelPropagation.stats.estimate",
    "gds.labelPropagation.stream",
    "gds.labelPropagation.stream.estimate",
    "gds.labelPropagation.write",
    "gds.labelPropagation.write.estimate",
    "gds.leiden.mutate",
    "gds.leiden.mutate.estimate",
    "gds.leiden.stats",
    "gds.leiden.stats.estimate",
    "gds.leiden.stream",
    "gds.leiden.stream.estimate",
    "gds.leiden.write",
    "gds.leiden.write.estimate",
    "gds.listProgress",
    "gds.localClusteringCoefficient.mutate",
    "gds.localClusteringCoefficient.mutate.estimate",
    "gds.localClusteringCoefficient.stats",
    "gds.localClusteringCoefficient.stats.estimate",
    "gds.localClusteringCoefficient.stream",
    "gds.localClusteringCoefficient.stream.estimate",
    "gds.localClusteringCoefficient.write",
    "gds.localClusteringCoefficient.write.estimate",
    "gds.louvain.mutate",
    "gds.louvain.mutate.estimate",
    "gds.louvain.stats",
    "gds.louvain.stats.estimate",
    "gds.louvain.stream",
    "gds.louvain.stream.estimate",
    "gds.louvain.write",
    "gds.louvain.write.estimate",
    "gds.maxkcut.mutate",
    "gds.maxkcut.mutate.estimate",
    "gds.maxkcut.stream",
    "gds.maxkcut.stream.estimate",
    "gds.modularityOptimization.mutate",
    "gds.modularityOptimization.mutate.estimate",
    "gds.modularityOptimization.stats",
    "gds.modularityOptimization.stats.estimate",
    "gds.modularityOptimization.stream",
    "gds.modularityOptimization.stream.estimate",
    "gds.modularityOptimization.write",
    "gds.modularityOptimization.write.estimate",
    "gds.node2vec.mutate",
    "gds.node2vec.mutate.estimate",
    "gds.node2vec.stream",
    "gds.node2vec.stream.estimate",
    "gds.node2vec.write",
    "gds.node2vec.write.estimate",
    "gds.nodeSimilarity.filtered.mutate",
    "gds.nodeSimilarity.filtered.mutate.estimate",
    "gds.nodeSimilarity.filtered.stats",
    "gds.nodeSimilarity.filtered.stats.estimate",
    "gds.nodeSimilarity.filtered.stream",
    "gds.nodeSimilarity.filtered.stream.estimate",
    "gds.nodeSimilarity.filtered.write",
    "gds.nodeSimilarity.filtered.write.estimate",
    "gds.nodeSimilarity.mutate",
    "gds.nodeSimilarity.mutate.estimate",
    "gds.nodeSimilarity.stats",
    "gds.nodeSimilarity.stats.estimate",
    "gds.nodeSimilarity.stream",
    "gds.nodeSimilarity.stream.estimate",
    "gds.nodeSimilarity.write",
    "gds.nodeSimilarity.write.estimate",
    "gds.pageRank.mutate",
    "gds.pageRank.mutate.estimate",
    "gds.pageRank.stats",
    "gds.pageRank.stats.estimate",
    "gds.pageRank.stream",
    "gds.pageRank.stream.estimate",
    "gds.pageRank.write",
    "gds.pageRank.write.estimate",
    "gds.prizeSteinerTree.mutate",
    "gds.prizeSteinerTree.mutate.estimate",
    "gds.prizeSteinerTree.stats",
    "gds.prizeSteinerTree.stats.estimate",
    "gds.prizeSteinerTree.stream",
    "gds.prizeSteinerTree.stream.estimate",
    "gds.prizeSteinerTree.write",
    "gds.prizeSteinerTree.write.estimate",
    "gds.scaleProperties.mutate",
    "gds.scaleProperties.mutate.estimate",
    "gds.scaleProperties.stats",
    "gds.scaleProperties.stats.estimate",
    "gds.scaleProperties.stream",
    "gds.scaleProperties.stream.estimate",
    "gds.scaleProperties.write",
    "gds.scaleProperties.write.estimate",
    "gds.scc.mutate",
    "gds.scc.mutate.estimate",
    "gds.scc.stats",
    "gds.scc.stats.estimate",
    "gds.scc.stream",
    "gds.scc.stream.estimate",
    "gds.scc.write",
    "gds.scc.write.estimate",
    "gds.session.delete",
    "gds.session.getOrCreate",
    "gds.session.list",
    "gds.shortestPath.astar.mutate",
    "gds.shortestPath.astar.mutate.estimate",
    "gds.shortestPath.astar.stream",
    "gds.shortestPath.astar.stream.estimate",
    "gds.shortestPath.astar.write",
    "gds.shortestPath.astar.write.estimate",
    "gds.shortestPath.dijkstra.mutate",
    "gds.shortestPath.dijkstra.mutate.estimate",
    "gds.shortestPath.dijkstra.stream",
    "gds.shortestPath.dijkstra.stream.estimate",
    "gds.shortestPath.dijkstra.write",
    "gds.shortestPath.dijkstra.write.estimate",
    "gds.shortestPath.yens.mutate",
    "gds.shortestPath.yens.mutate.estimate",
    "gds.shortestPath.yens.stream",
    "gds.shortestPath.yens.stream.estimate",
    "gds.shortestPath.yens.write",
    "gds.shortestPath.yens.write.estimate",
    "gds.sllpa.mutate",
    "gds.sllpa.mutate.estimate",
    "gds.sllpa.stats",
    "gds.sllpa.stats.estimate",
    "gds.sllpa.stream",
    "gds.sllpa.stream.estimate",
    "gds.sllpa.write",
    "gds.sllpa.write.estimate",
    "gds.spanningTree.mutate",
    "gds.spanningTree.mutate.estimate",
    "gds.spanningTree.stats",
    "gds.spanningTree.stats.estimate",
    "gds.spanningTree.stream",
    "gds.spanningTree.stream.estimate",
    "gds.spanningTree.write",
    "gds.spanningTree.write.estimate",
    "gds.steinerTree.mutate",
    "gds.steinerTree.mutate.estimate",
    "gds.steinerTree.stats",
    "gds.steinerTree.stats.estimate",
    "gds.steinerTree.stream",
    "gds.steinerTree.stream.estimate",
    "gds.steinerTree.write",
    "gds.steinerTree.write.estimate",
    "gds.triangleCount.mutate",
    "gds.triangleCount.mutate.estimate",
    "gds.triangleCount.stats",
    "gds.triangleCount.stats.estimate",
    "gds.triangleCount.stream",
    "gds.triangleCount.stream.estimate",
    "gds.triangleCount.write",
    "gds.triangleCount.write.estimate",
    "gds.wcc.mutate",
    "gds.wcc.mutate.estimate",
    "gds.wcc.stats",
    "gds.wcc.stats.estimate",
    "gds.wcc.stream",
    "gds.wcc.stream.estimate",
    "gds.wcc.write",
    "gds.wcc.write.estimate",
    "genai.vector.encodeBatch"
  ]
}
(.venv) root@MOSAB:/home/mosab/projects/chatmodule# 